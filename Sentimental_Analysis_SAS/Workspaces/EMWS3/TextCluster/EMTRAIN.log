MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "January 16, 2022" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "18:08:04" );
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Training Log";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
*------------------------------------------------------------*
* Training Log
Date:                January 16, 2022
Time:                18:08:04
*------------------------------------------------------------*
MPRINT(EM_DIAGRAM):    filename O0AHWB4C "D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextCluster\EMTRAIN.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   proc printto print=O0AHWB4C new;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOG "D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextCluster\EMLOG.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "January 16, 2022" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "18:08:04" );
MPRINT(EM_DIAGRAM):   file _LOG;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "User:                hp";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "Site:                70166022";
MPRINT(EM_DIAGRAM):   put "Platform:            W32_10HOME";
MPRINT(EM_DIAGRAM):   put "Maintenance Release: 9.04.01M5P091317";
MPRINT(EM_DIAGRAM):   put "EM Version:          14.3";
MPRINT(EM_DIAGRAM):   put "* ";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOGIN "D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextCluster\EMTRAIN.log" encoding="UTF-8" NOBOM;
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file _LOG MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("_LOGIN",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _LOGIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _LOG mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   filename _LOGIN "D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextCluster\EMSCORE.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   file _LOG mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOGIN "D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextCluster\EMREPORT.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _LOGIN;
MPRINT(EM_DIAGRAM):    filename _LOG;
MPRINT(EM_DIAGRAM):    filename _OUT "D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextCluster\EMOUTPUT.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "January 16, 2022" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "18:08:04" );
MPRINT(EM_DIAGRAM):   file _OUT;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "User:                hp";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Training Output";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextCluster\EMTRAIN.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   ;
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file _OUT MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("_OUTIN",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _OUT mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   put // "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Score Output";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextCluster\EMSCORE.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _OUT mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   put // "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Report Output";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextCluster\EMREPORT.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    filename _OUT;
MPRINT(EM_DIAGRAM):    filename _emtool_ 'D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextCluster\EMRUNSTATUS.xml' encoding="UTF-8" NOBOM;
32658      proc freq data=EMWS3.TextCluster_VariableSet noprint;
MPRINT(EM_DIAGRAM):    proc freq data=EMWS3.TextCluster_VariableSet noprint;
32659      table ROLE*LEVEL/out=WORK.TextClusterMETA;
MPRINT(EM_DIAGRAM):   table ROLE*LEVEL/out=WORK.TextClusterMETA;
32660      run;
MPRINT(EM_DIAGRAM):   run;

NOTE: There were 1 observations read from the data set EMWS3.TEXTCLUSTER_VARIABLESET.
NOTE: The data set WORK.TEXTCLUSTERMETA has 1 observations and 4 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

32661      proc print data=WORK.TextClusterMETA label noobs;
MPRINT(EM_DIAGRAM):   proc print data=WORK.TextClusterMETA label noobs;
32662      var ROLE LEVEL COUNT;
MPRINT(EM_DIAGRAM):   var ROLE LEVEL COUNT;
32663      label ROLE = "%sysfunc(sasmsg(sashelp.dmine, meta_role_vlabel, NOQUOTE))" LEVEL = "%sysfunc(sasmsg(sashelp.dmine, meta_level_vlabel, NOQUOTE))" COUNT = "%sysfunc(sasmsg(sashelp.dmine, rpt_count_vlabel, NOQUOTE))";
MPRINT(EM_DIAGRAM):   label ROLE = "Role" LEVEL = "Measurement Level" COUNT = "Frequency Count";
32664      title9 ' ';
MPRINT(EM_DIAGRAM):   title9 ' ';
32665      title10 "%sysfunc(sasmsg(sashelp.dmine, rpt_varSummary_title  , NOQUOTE))";
MPRINT(EM_DIAGRAM):   title10 "Variable Summary";
MPRINT(EM_DIAGRAM):   run;
32666      run;

NOTE: There were 1 observations read from the data set WORK.TEXTCLUSTERMETA.
NOTE: The PROCEDURE PRINT printed page 2.
NOTE: PROCEDURE PRINT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

32667      title10;
MPRINT(EM_DIAGRAM):   title10;
32668      %let EMEXCEPTIONSTRING=;
MPRINT(EM_DIAGRAM):     *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * TextCluster: Generation of macros and macro variables;
MPRINT(EM_DIAGRAM):   * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * TextCluster: EM Macro Variables and Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   * System Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   length string $2000;
MPRINT(EM_DIAGRAM):   string = 'Sentimental_Analysis_SAS';
MPRINT(EM_DIAGRAM):   call symput('EM_PROJECTNAME', trim(string));
MPRINT(EM_DIAGRAM):   string = 'Resaturant_Review';
MPRINT(EM_DIAGRAM):   call symput('EM_WSNAME', trim(string));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   * Properties Macro Variables ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Files Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Import Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Export Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Decision Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Statement Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   set EMWS3.TextFilter_EMINFO;
MPRINT(EM_DIAGRAM):   where key in('HPDMSAMPLE', 'IDSTABLE');
MPRINT(EM_DIAGRAM):   if key = 'HPDMSAMPLE' then call symput('_ForceGrid', '1');
MPRINT(EM_DIAGRAM):   else call symput('_IDS_TABLE', DATA);
MPRINT(EM_DIAGRAM):   run;
MPRINT(HPDM_PERFORMANCE):  ;
PERFORMANCE  DETAILS
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * General Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Target Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Input Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Rejected Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Misc Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End Create EM Macro Variables and Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
32988      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
32989      * TextCluster: Generation of macros and macro variables;
MPRINT(EM_DIAGRAM):   * TextCluster: Generation of macros and macro variables;
32990      * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
MPRINT(EM_DIAGRAM):   * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
32991      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;

32992      %let EMEXCEPTIONSTRING=;
32993      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
32994      * TRAIN: TextCluster;
MPRINT(EM_DIAGRAM):   * TRAIN: TextCluster;
32995      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
32996      %let EM_ACTION = TRAIN;
32997      %let syscc = 0;
32998      %macro main();
32999      
33000         %if %upcase(&EM_ACTION) eq CREATE %then %do;
33001            filename temp catalog 'sashelp.emtxtext.cluster_create.source';
33002            %include temp;
33003            %create();
33004         %end;
33005         %if %upcase(&EM_ACTION) eq TRAIN %then %do;
33006            filename temp catalog 'sashelp.emtxtext.cluster_train.source';
33007            %include temp;
33008            %train();
33009         %end;
33010         %if %upcase(&EM_ACTION) eq REPORT %then %do;
33011            filename temp catalog 'sashelp.emtxtext.cluster_report.source';
33012            %include temp;
33013            %report();
33014         %end;
33015         %if %upcase(&EM_ACTION) eq SCORE %then %do;
33016            filename temp catalog 'sashelp.emtxtext.cluster_score.source';
33017            %include temp;
33018            %score();
33019         %end;
33020      %mend main;
33021      
33022      %main();
MPRINT(EM_DIAGRAM):    
MPRINT(MAIN):   filename temp catalog 'sashelp.emtxtext.cluster_train.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTXTEXT.CLUSTER_TRAIN.SOURCE.
33023     +%macro train();
33024     +
33025     +    %global last_parse_node last_filter_node last_prescore_node server_err
33026     +      parsevar EM_SASMSG;
33027     +    %if ^%symexist(tm_debug) %then %let tm_debug=0;
33028     +    %let EM_SASMSG=TMINE;
33029     +    %let syscc=0;
33030     +
33031     +    filename temp catalog 'sashelp.emtxtext.tm_get_last_filter.source';
33032     +    %include temp;
33033     +    filename temp catalog 'sashelp.emtxtext.tm_cluster.source';
33034     +    %include temp;
33035     +    filename temp catalog 'sashelp.emtxtext.tm_apply_tmutil.source';
33036     +    %include temp;
33037     +    filename temp catalog 'sashelp.emtxtext.tm_svd_do_samp.source';
33038     +    %include temp;
33039     +    filename temp;
33040     +
33041     +    %tm_get_last_filter(eminfo=&EM_IMPORT_DATA_EMINFO,em_lib=&em_lib,
33042     +                        em_variableset=&em_data_variableset);
33043     +    %if &EMEXCEPTIONSTRING ne %then %goto end_cluster_train;
33044     +    %let lastparsenode=&last_parse_node;
33045     +    %let lastfilternode=&last_filter_node;
33046     +    %let lastprescore=&last_prescore_node;
33047     +    %if &lastfilternode=&lastparsenode %then %do;
33048     +        %let EMEXCEPTIONSTRING = EMTOOL.NOFILTERNODE;
33049     +        %goto end_cluster_train;
33050     +    %end;
33051     +
33052     +    /*populate last tm node dataset so tm_get_last_filter is not called in score*/
33053     +    %em_getname(key=last_tm_nodes, type=data);
33054     +    data &em_user_last_tm_nodes;
33055     +        set &EM_IMPORT_DATA_EMINFO;
33056     +    run;
33057     +
33058     +
33059     +    %em_getname(key=tmconfig, type=data);
33060     +    %em_getname(key=terms, type=data);
33061     +    %em_getname(key=docs, type=data);
33062     +    %em_getname(key=clusters, type=data);
33063     +    %em_getname(key=graph_table, type=data);
33064     +    %em_getname(key=svd_u, type=data);
33065     +    %em_getname(key=tmconfig, type=data);
33066     +    %em_getname(key=svd_s, type=data);
33067     +    %em_getname(key=emoutstat, type=data);
33068     +    %em_getname(key=hierds, type=data);
33069     +
33070     +
33071     +
33072     +    /* get target variable info */
33073     +    %let targetvar = ;
33074     +    data _null_;
33075     +       set &em_data_variableset(where=(ROLE='TARGET' and USE in('Y' 'D')
33076     +                                       and LEVEL ne 'INTERVAL'));
33077     +       if _N_=1 then call symput('targetvar', strip(NAME));
33078     +    run;
33079     +
33080     +
33081     +
33082     +    /* set up terms strings and initial config table */
33083     +    proc sql noprint;
33084     +      create table &EM_USER_tmconfig as
33085     +         select *
33086     +         from &EM_LIB..&last_filter_node._tmconfig;
33087     +    quit;
33088     +
33089     +
33090     +    proc sql noprint;
33091     +       select  cellwgt into: _cellweight
33092     +       from &em_user_tmconfig;
33093     +       select termwgt into: _termwgt
33094     +       from &em_user_tmconfig;
33095     +    quit;
33096     +
33097     +    data _keepdocs (keep=_DOCUMENT_ %if &targetvar ne %then &targetvar; );
33098     +        set &EM_IMPORT_DATA;
33099     +    run;
33100     +
33101     +    %tm_apply_tmutil(data=&EM_LIB..&last_filter_node._tmout,
33102     +                       terms=&EM_LIB..&last_filter_node._terms,
33103     +                       docs=&EM_IMPORT_DATA,
33104     +                       keepdocs=_keepdocs,
33105     +                       reduceF=2,
33106     +                       termweight=&_termwgt,
33107     +                       cellweight=&_cellweight,
33108     +                       outdata=_outtmutil_,
33109     +                       outterms=_newkey,
33110     +                       outweights=_weights,
33111     +                       targetvar=&targetvar,
33112     +                       memloc=_tmmem);
33113     +
33114     +                       /* get the svd dimensions on the documents */
33115     +    %tm_svd_do_samp(data=_outtmutil_,docs=_keepdocs, maxK=&em_property_maxK, res=&em_property_resolution,cellwgt=&_cellweight,in_global=_weights,
33116     +                     rowVar=_termnum_,colVar=_document_,entryVar=_count_,u=&EM_USER_SVD_U,v=_svdv,s=&EM_USER_svd_S,
33117     +                     colpro=_svdcolpro,rowpro=_svdrowpro, normcol=normcol, normrow=normrow,prefix=&EM_NODEID);
33118     +
33119     +    %if(&syscc >4 ) %then %do;
33120     +        %goto end_cluster_train;
33121     +    %end;
33122     +
33123     +    proc sql noprint;
33124     +       create table &EM_USER_TERMS(drop=index) as
33125     +       select a.*,b.*
33126     +       from &EM_LIB..&last_filter_node._terms a left join _svdrowpro b
33127     +       on a.key = b.index;
33128     +    quit;
33129     +
33130     +    %tm_cluster(data=&EM_LIB..&last_filter_node._tmout,
33131     +        terms=&EM_LIB..&last_filter_node._terms,
33132     +        docs=&EM_IMPORT_DATA,
33133     +        svdColPro=_svdcolpro,
33134     +        maxNumTerms=&em_property_ndescterms,
33135     +        numClus=&em_property_nclusters,
33136     +        numType=&em_property_exactormaximum,
33137     +        algorithm=&em_property_algorithm,
33138     +        outdocs=&EM_USER_DOCS,
33139     +        outclusters=&EM_USER_CLUSTERS,
33140     +        hierds=&EM_USER_HIERDS,
33141     +        emoutstat=&EM_USER_emoutstat,
33142     +        prefixstring= &EM_NODEID);
33143     +
33144     +    %if &emexceptionstring ne %then %goto end_cluster_train;
33145     +
33146     +    %if &em_property_algorithm=2.0 %then %do;
33147     +
33148     +        data &em_user_hierds(drop=plus);
33149     +            set &em_user_hierds;
33150     +            plus='';
33151     +            if substr(CLUS_DESC, 1, 1) = "+" then plus="+ ";
33152     +            graphdesc=_CLUSTER_ || ': ' || plus || scan(CLUS_DESC, 1);
33153     +        run;
33154     +    %end;
33155     +
33156     +
33157     +    * add the info to EMINFO to forward on to other nodes ;
33158     +   data &EM_DATA_EMINFO;
33159     +      length TARGET KEY $32 DATA $43;
33160     +
33161     +      key="LastTMNode";
33162     +      data="&EM_NODEID";
33163     +      output;
33164     +
33165     +      key="LastTMNodeType";
33166     +      data="TextCluster";
33167     +      output;
33168     +
33169     +      key="LastTextCluster";
33170     +      data="&EM_NODEID";
33171     +      output;
33172     +
33173     +      key="PRESCORECODE";
33174     +      data="&EM_NODEID";
33175     +      output;
33176     +   run;
33177     +
33178     +    proc sql noprint;
33179     +        select count(*) into :svdkeep
33180     +            from &em_user_svd_s
33181     +            where keep=1;
33182     +        select count(*) into :cluscnt
33183     +            from &em_user_clusters;
33184     +    quit;
33185     +   data &EM_USER_tmconfig;
33186     +         set &EM_USER_TMCONFIG;
33187     +         clus_alg = "&em_property_algorithm";
33188     +         maxsvd = &em_property_maxk;
33189     +         svdkeep=&svdkeep;
33190     +         last_prescore = "&last_prescore_node";
33191     +      run;
33192     +
33193     +    %em_metachange(name=&EM_NODEID._CLUSTER_, role=SEGMENT, level=NOMINAL);
33194     +    %do i=1 %to &svdkeep;
33195     +         %em_metachange(name=&EM_NODEID._SVD&i, role=INPUT, level=INTERVAL);
33196     +    %end;
33197     +    %do i=1 %to &cluscnt;
33198     +         %em_metachange(name=&EM_NODEID._PROB&i, role=REJECTED);
33199     +    %end;
33200     +
33201     +%end_cluster_train:
33202     +    filename temp;
33203     +    %if &tm_debug =0 %then %do;
33204     +        proc sql noprint;
33205     +              drop table _svdcolpro;
33206     +              drop table _svdrowpro;
33207     +              drop table _newkey ;
33208     +              drop table _keepdocs ;
33209     +        quit;
33210     +    %end;
33211     +
33212     +%mend train;
33213     +
NOTE: %INCLUDE (level 1) ending.
MPRINT(TRAIN):   filename temp catalog 'sashelp.emtxtext.tm_get_last_filter.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTXTEXT.TM_GET_LAST_FILTER.SOURCE.
33214     +/* ****************************************************************
33215     + * Copyright (C) 2009 by SAS Institute Inc., Cary, NC 27513
33216     + *
33217     + * Name:             tm_get_last_filter.sas
33218     + * Product:          SAS Text Miner
33219     + * Language:         Sas
33220     + * Script:
33221     + *
33222     + * Usage:
33223     + *
33224     + * Purpose:  macro to get the last filter node and the last parse node in the
33225     + *   diagram that corresponds to the current parse variable.  If there is no filter
33226     + *   node, the filter node is set to the last parse node.
33227     + *
33228     + *
33229     + *
33230     + * History:
33231     + * 14Aug09 Initial Coding
33232     + *
33233     + * Notes:
33234     + *    Returns an error in the following cases:
33235     + *      1. There is no preceding parse node.
33236     + *      2. There is no parse node with the current parse variable.
33237     + *
33238     + * Last Modified By:
33239     + * Last Modified On: Wed Sep 23 15:35:04 2009
33240     + *
33241     + * End
33242     + * ************************************************************** */
33243     +%macro tm_get_last_filter(eminfo=,em_lib=, em_variableset=);
33244     +   %let last_parse_node=;
33245     +   %let last_filter_node=;
33246     +   %let last_prescore_node=;
33247     +   %let server_err=;
33248     +   %let EMEXCEPTIONSTRING=;
33249     +   %let syscc=0;
33250     +
33251     +    /* verify that setinit for SAS Text Miner is currently active */
33252     +    %if %sysfunc(sysprod(PRODNUM107)) ne 1 %then %do;
33253     +       %let EMEXCEPTIONSTRING = EMTOOL.NOTMLICENSE;
33254     +        %goto end_macro;
33255     +        %end;
33256     +
33257     +
33258     +    * find last filter or text parse node if no filter node. ;
33259     +   %if %sysfunc(exist(&eminfo)) %then %do;
33260     +      proc sql noprint;
33261     +      select data into :last_parse_node from &eminfo where key="LastTextParsing";
33262     +         select data into :last_filter_node from &eminfo where key="LastTextFilter";
33263     +         select data into :last_prescore_node from &eminfo where kupcase(key)="PRESCORECODE";
33264     +      quit;
33265     +
33266     +   %end;
33267     +
33268     +   %if &last_parse_node= %then %do;
33269     +      %let EMEXCEPTIONSTRING = EMTOOL.NOPARSINGNODE;
33270     +      %goto end_macro;
33271     +      %end;
33272     +
33273     +   %else %if &last_filter_node= %then %let last_filter_node = %ktrim(&last_parse_node);
33274     +   %else %let last_filter_node = %ktrim(&last_filter_node);
33275     +   %let last_parse_node = %ktrim(&last_parse_node);
33276     +
33277     +   * Check to make sure parse variable is present and still exists;
33278     +   %let parsevar = ;
33279     +   proc sql noprint;
33280     +    select parsevar into :parsevar
33281     +    from &em_lib..&last_filter_node._tmconfig;
33282     +    quit;
33283     +
33284     +    *check for dropped parsevar on input dataset;
33285     +       %let parsevarOK= ;
33286     +       %let parsevarN=%kupcase(%ktrim(&parsevar));
33287     +       data _null_;
33288     +         set &em_variableset(where=(kupcase(NAME)="&parsevarN" and USE in('Y' 'D')));
33289     +         if (ROLE='TEXT' or ROLE='TEXTLOC') then call symput('parsevarOK', strip(ROLE));
33290     +         run;
33291     +       %if(&parsevarOK eq ) %then %do;
33292     +          %let EMEXCEPTIONSTRING = EMTOOL.NOPARSINGVAR;
33293     +          %goto end_macro;
33294     +          %end;
33295     +%end_macro:
33296     +
33297     +%mend tm_get_last_filter;
NOTE: %INCLUDE (level 1) ending.
MPRINT(TRAIN):   filename temp catalog 'sashelp.emtxtext.tm_cluster.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTXTEXT.TM_CLUSTER.SOURCE.
33299     +   /* ****************************************************************
33300     + * Copyright (C) 2009 by SAS Institute Inc., Cary, NC 27513
33301     + *
33302     + * Name:             tm_cluster.sas
33303     + * Support:          rualbr Russell Albright
33304     + * Product:
33305     + * Language:         Sas
33306     + * Script:
33307     + *
33308     + * Usage:
33310     + !Inputs into %tm_train_cluster
33311     + * doc = doc datset from a tm node
33312     + * data =  out datset from a tm node
33313     + * terms = terms dataset from  tm node
33314     + * svdcolpro = column projections data set
33315     + * cellweight setting
33316     + * termweight setting
33317     + * maxSvddim = Maximum number of dimension to calculate
33318     + * svdres= <HIGH, MED, or LOW>
33319     + * maxNumTerms - maximum number of term to use for descriptive terms
33320     + * numClus = number of clusters to use
33321     + * numType=<MAXIMUM or EXACT> Max means that <= maximum will actually be used.
33322     + * threads = the number of threads you would like emclus to use
33325     + !Outputs from %tm_train_cluster
33326     + * outdocs - a doc table with the cluster restults on it.
33327     + * outclusters- an output cluster table with the descriptive terms on it (future story)
33328     + *
33329     + * Example call
33330     + *
33331     + *%tm_cluster(data=tmn.text_out_t,
33332     + *             terms=tmn.terms,
33333     + *             docs=testdata._train,
33334     + *             svdcolpro=tmn._svdcolpro,
33335     + *             maxNumTerms=5,
33336     + *             numClus=40,
33337     + *             numType=MAXIMUM,
33338     + *             outdocs=docsresult,
33339     + *             hierds=_hierds,
33340     + *             emoutstat=_emoutstat,
33341     + *             outclusters= clusterResult);
33342     + *
33343     + *
33344     + * Purpose: Perform the clustering on out,term, doc from parse or filter node
33345     + *
33346     + * History:
33347     + *
33348     + *
33349     + * Notes:
33350     + *
33351     + * Last Modified By:
33352     + * Last Modified On: Thu Jan 08 17:22:43 2009
33353     + *
33354     + * End
33355     + * ************************************************************** */
33357     +%macro tm_cluster(data=,
33358     +                     terms=,
33359     +                     docs=,
33360     +                     svdColPro=,
33361     +                     maxNumTerms=,
33362     +                     numClus=,
33363     +                     numType=MAXIMUM,
33364     +                     algorithm=,
33365     +                     outdocs=,
33366     +                     hierds=_hierds,
33367     +                     emoutstat=_emoutstat,
33368     +                     outclusters=,
33369     +                     prefixString=,
33370     +                     threads=);
33373     +    %local _cleanedout ;
33374     +    %local _numRepDocs;
33375     +    %global systmutil;
33376     +    %let systmutil = ;
33377     +    %if ^%symexist(tm_debug) %then %let tm_debug=0;
33379     +    filename temp catalog 'sashelp.emtext.tmgetncl.source';
33380     +    %include temp;
33381     +    filename temp catalog 'sashelp.emtext.tmfast.source';
33382     +    %include temp;
33384     +    filename temp catalog 'sashelp.emtext.tmemclus.source';
33385     +    %include temp;
33387     +    filename temp catalog 'sashelp.emtext.tmpred.source';
33388     +    %include temp;
33390     +    filename temp catalog 'sashelp.emtext.tmsort.source';
33391     +    %include temp;
33393     +    %let tmdata=&data;
33394     +    %let tmterms=&terms;
33395     +    %let tmdocs=&docs;
33396     +    %let emexceptionstring=;
33399     +    /* check some basic size requirements to proceed.*/
33400     +    proc sql noprint;
33401     +       select count(*) into: numTerms
33402     +       from &terms a
33403     +       where a.numdocs>=2 and _ispar in('+',' ')
33404     +       ;
33405     +       select count (*) into: numdocs
33406     +       from &docs a;
33407     +    quit;
33409     +    %if (&numterms < 10)  OR (&numdocs< 8) %then %do;
33410     +        %let emexceptionstring=EMTOOL.INSUFFICIENTDATA;
33411     +        %goto end_train_cluster;
33412     +    %end;
33414     +    /* Get number of kept svd variables */
33415     +    %let pid = %sysfunc(open(&svdcolpro));
33416     +    %let svdkeep=%eval(%sysfunc(attrn(&pid,nvars))-1);
33417     +    %let rc = %sysfunc(close(&pid));
33420     +   /************************ Find clusters *************************************/
33422     +   %if %upcase(&numType) = MAXIMUM %then %do;   /* numClus = MAXIMUM */
33424     +      /* Call tmgetncl to find the recommended number of clusters. */
33426     +      %tmGetNcl(data=&svdcolpro,
33427     +               maxclusters=&numClus,
33428     +               vars=%str(&prefixstring._SVD1 - &prefixstring._SVD&svdkeep),
33429     +               tempDS=_clusTemp1,
33430     +               clusDS=_clusTemp,
33431     +               threads=
33432     +            );
33434     +      /* error returned in above macro */
33435     +      %if (&syscc >4 ) %then %do;
33436     +         %let emexceptionstring= &SYSERRORTEXT;
33437     +         %goto end_train_cluster;
33438     +      %end;
33440     +      /* Store the recommended number into a macro variable. */
33442     +      proc sql noprint;
33443     +         select max(nclus) into: numClus
33444     +         from _clusTemp
33445     +         ;
33446     +      quit;
33449     +      %if not (&numClus > 1) %then %do;
33450     +        %let numClus = 2;
33451     +      %end;
33454     +       %if &tm_debug =0  %then %do;
33455     +          proc sql nowarn noprint;
33456     +              drop table _clustemp;
33457     +              drop table _clustemp1;
33458     +           quit;
33459     +       %end;
33461     +   %end;  /* &numtype = MAXIMUM */
33463     +   %else  %do;
33464     +       %let numClus = %left(&numClus);/*&numtype=EXACT*/
33465     +   %end;
33467     +    proc sql noprint;
33468     +        select count(*) into: nobs
33469     +        from &svdcolpro;
33470     +    quit;
33472     +   %if %left(&algorithm)=2.0 %then %do; /* Hierarchical clustering */
33473     +        filename temp catalog 'sashelp.emtxtext.tmgethclus.source';
33474     +        %include temp;
33476     +        filename temp catalog 'sashelp.emtext.tmhclus.source';
33477     +        %include temp;
33478     +        filename temp catalog 'sashelp.emtext.tmtree.source';
33479     +        %include temp;
33481     +        %if &nobs < &numClus and  %upcase(&numType) = EXACT %then %do;
33482     +            %let emexceptionstring=EMTOOL.TOOFEWOBSTOCLUS;
33483     +            %goto end_train_cluster;
33484     +        %end;
33486     +        %tmgethclus(outtree=_outtree,
33487     +                    idvar=index,
33488     +                    inDS=&svdcolpro,
33489     +                    outDS=&outdocs,
33490     +                    fastOut=_fastclusstat,
33491     +                    textClusDS=_clusstat,
33492     +                    vars=%str(&prefixstring._SVD1 - &prefixstring._SVD&svdkeep),
33493     +                    nobs=&nobs,
33494     +                    nclus=&numClus,
33495     +                    hierds=&hierds,
33496     +                    svdkeep=&svdkeep,
33497     +                    prefix=&prefixString);
33498     +        %if &EMEXCEPTIONSTRING ne %then %goto end_train_cluster;
33500     +        data _clusstat;
33501     +            set _clusstat(rename=(&prefixstring._SVD1 - &prefixstring._SVD&svdkeep.=_mean1-_mean&svdkeep.));
33502     +        run;
33504     +        data _clustermean;
33505     +          set _clusstat(keep=_cluster_ _mean1-_mean&svdkeep. rename=(_cluster_=cluster));
33506     +        run;
33508     +        proc sql noprint;
33509     +            drop table _outtree;
33510     +        quit;
33511     +   %end;
33512     +   %else %do; /* Expectation-maximization */
33513     +       /* Call %anl_tmfast to create cluster stat data set that will be used as an input for %anl_tmemclus. */
33514     +          %tmFast(data=&svdcolpro,
33515     +             clusters=&numClus,
33516     +             outstat=_fastclusstat,
33517     +             outseed=,
33518     +                id=,
33519     +             out=,
33520     +             vars=%str(&prefixstring._SVD1 - &prefixstring._SVD&svdkeep)
33521     +             );
33522     +          run;
33524     +          /* If some of the clusters are too small (frequency less than 5) and &g_numClusFlag=MAXIMUM, */
33525     +          /* reassign value for &cluster macro var from WORK.&s_reportID._fastclusstat data set. */
33527     +       %if %upcase(&numType) = MAXIMUM %then
33528     +       %do;   /* &ClusType = MAXIMUM */
33530     +          proc sql noprint;
33531     +             select max(CLUSTER) into :numClus
33532     +             from _fastclusstat
33533     +             where upcase(_TYPE_)='SEED'
33534     +             ;
33535     +          quit;
33537     +          %let numClus = %left(&numClus);
33539     +       %end;  /* &ClusType = MAXIMUM */
33540     +       %else %do; /* &ClusType = EXACT */
33541     +          %if &nobs < &numClus %then %do;
33542     +            %let emexceptionstring=EMTOOL.TOOFEWOBSTOCLUS;
33543     +            %goto end_train_cluster;
33544     +          %end;
33545     +       %end;
33547     +       %tmEMClus(data=&svdcolpro,
33548     +                role=TRAIN,
33549     +                clusters=&numClus,
33550     +                seed=_fastclusstat,
33551     +                outstat=&emoutstat,
33552     +                out=_tmutildoc,
33553     +                vars=%str(&prefixstring._SVD1 - &prefixstring._SVD&svdkeep),
33554     +                cov=,
33555     +                iter=5,
33556     +                secclus=,
33557     +                seciter=,
33558     +                min=,
33559     +                method=,
33560     +                eps=.1,
33561     +                init=FASTCLUS,
33562     +                print=NONE,
33563     +                p=,
33564     +                outliers=,
33565     +                decvar=0,
33566     +                initstd=,
33567     +                dist=,
33568     +                secstd=,
33569     +                nobs=,
33570     +                threads=&threads.
33571     +             );
33572     +       run;
33575     +       /* Run %anl_tmpred macro to assign documents to clusters with the largest posterior probability */
33576     +       /* and to calculate cluster frequency. */
33578     +       %tmPred (inds=_tmutildoc,
33579     +                outds=&outdocs,
33580     +              clusters=&numClus,
33581     +              type=max,
33582     +              freqds=_clusstat,
33583     +              compress=1
33584     +              );
33585     +        data &outdocs;
33586     +           set &outdocs;
33587     +           rename prob1-prob&numClus = &prefixString._prob1-&prefixString._prob&numclus;
33588     +        run;
33592     +       /* Transpose the output data set to contain cluster ID and cluster frequency. */
33594     +        data _clusstat;
33595     +            array c(&numClus) _c1-_c&numClus;
33596     +            set _clusstat;
33597     +            /*keep _CLUSTER_ Freq;*/
33598     +            totalobs=0;
33599     +            do _CLUSTER_ = 1 to &numClus;
33600     +                Freq = c(_CLUSTER_);
33601     +                totalobs=totalobs+c(_CLUSTER_);
33602     +                output;
33603     +            end;
33604     +            call symput ('totNumDocs', totalobs);
33605     +        run;
33607     +       %if &totNumDocs = 0 %then
33608     +       %do;   /*&totNumDocs = 0 */
33609     +           goto end_train_cluster;
33610     +       %end; /*&totNumDocs = 0 */
33612     +       /* Calculate cluster percentage. */
33613     +       data _clusstat;
33614     +          set _clusstat;
33615     +          Percent = Freq/&totNumDocs;
33616     +       run;
33618     +       data _clustermean(rename=(&prefixstring._SVD1 - &prefixstring._SVD&svdkeep. = _mean1-_mean&svdkeep.));
33619     +          set &emoutstat(keep=cluster _TYPE_ &prefixstring._SVD1 - &prefixstring._SVD&svdkeep.);
33620     +          if _TYPE_ = "MEAN";
33621     +            keep cluster &prefixstring._SVD1 - &prefixstring._SVD&svdkeep. ;
33622     +      run;
33623     +  %end;
33625     +      proc sql;
33626     +      create table _meandocs(drop=cluster) as
33627     +      select a.*, b.*
33628     +      from &outdocs a left join _clustermean b
33629     +      on a._cluster_=b.cluster
33630     +      ;
33631     +      quit;
33632     +       /*calulate residual for each doc */
33633     +      data _rmscalc;
33634     +          merge _meandocs(in=inhere) _clusstat;
33635     +          array _means(&svdkeep) _mean1-_mean&svdkeep.;
33636     +          array _svds(&svdkeep) &prefixstring._SVD1 - &prefixstring._SVD&svdkeep.;
33637     +          by _cluster_;
33638     +          error=0;
33639     +          do i = 1 to &svdkeep;
33640     +             error +( (_svds{i}-_means{i}) * (_svds{i}-_means{i}));
33641     +          end;
33642     +         /*error=sqrt(error);*/
33643     +          drop i;
33644     +       run;
33645     +    /*calc standardized residual for clusters*/
33646     +       proc summary data=_rmscalc nway;
33647     +          class _cluster_;
33648     +          var error;
33649     +          output out=_meanerr mean=meane sum=sume;
33650     +       run;
33652     +       data _rmsse;
33653     +          set _meanerr;
33654     +          /* original code divides by number of svd dims*/
33655     +          if _freq_ gt 1 then do;
33656     +              _rmsstd_=sqrt(sume/((_freq_-1)*(&svdkeep.)));
33657     +          end;
33658     +          else do;
33659     +              _rmsstd_=0;
33660     +          end;
33661     +          keep _cluster_  _rmsstd_;
33662     +       run;
33665     +       proc sql;
33666     +           create table _clusstat2(drop=cluster) as
33667     +           select a.*,b.*
33668     +           from _clustermean a left join _rmsse b
33669     +           on a.cluster=b._cluster_;
33671     +           create table &outclusters as
33672     +           select  a.*, b.freq, b.percent
33673     +           from _clusstat2(keep=_cluster_ %str(_mean1-_mean&svdkeep) _rmsstd_) a right join _clusstat b
33674     +           on a._cluster_=b._cluster_
33675     +           where b.freq>0 ;
33676     +       quit;
33679     +    filename temp catalog 'sashelp.emtext.tmterm1.source';
33680     +    %include temp / nosource2;
33682     +   /****************** Find descriptive terms for clusters ***************************/
33685     +   /* Add _term_ variable to WORK._terms data set to prepare it as an
33686     +   /* input to %tmterm1 macro. The variable is added from &EM_LIB..&last_filter_node._terms data set. */
33688     +   proc sort data=&tmterms out=_terms_;
33689     +        by key _ispar;
33690     +   run;
33692     +   data _terms_;
33693     +       set _terms_;
33694     +       by key _ispar;
33695     +       if first.key then
33696     +          output;
33697     +       else;
33698     +   run;
33700     +    /* Concatenate + to terms */
33701     +    data _terms_;
33702     +        set _terms_;
33703     +        if _ispar='+' then
33704     +            Term=_ispar || ' ' || term;
33705     +    run;
33707     +   %tmsort(data=&tmdata,
33708     +         out=_tmout_,
33709     +         by=_termnum_,
33710     +            options=,
33711     +         threads=threads);
33714     +   data _tmout_;
33715     +      merge _tmout_ (in=_A_)
33716     +            _terms_ (rename=(key=_termnum_ term=_term_) keep=key term );
33717     +      by _termnum_;
33718     +      if _A_;
33719     +   run;
33721     +   /* Create _segmnt_ variable in WORK._docs data set to prepare it to be an */
33722     +   /* input to %tmterm1 macro. Set it equal to _cluster_ variable. */
33724     +   %if &algorithm=2.0 %then %do;
33725     +        data _docs_;
33726     +            set &outdocs (rename=(index=_document_) keep=index _cluster_ _finalcluster_);
33727     +            _SEGMNT_=_finalcluster_;
33728     +        run;
33729     +        proc sql noprint;
33730     +            select max(_cluster_) into :numclus from &outclusters;
33731     +        quit;
33732     +   %end;
33733     +   %else %do;
33734     +       data _docs_;
33735     +        set &outdocs (rename=(index=_document_) keep=index _cluster_);
33736     +         _SEGMNT_=_cluster_;;
33737     +       run;
33739     +   %end;
33741     +   /* Run %tmterm1 macro to determine descriptive terms for clusters. */
33742     +   %tmterm1(DSN_TPARS=_tmout_,
33743     +        DSN_CLUS=_docs_,
33744     +        DSN_DESC=_desc_,
33745     +        N_DESC_TERMS=&maxnumterms,
33746     +        N_CLUS=&numclus,
33747     +        top_freq=%eval(&maxnumterms*2),
33748     +        key=);
33750     +    /* Add cluster descriptive terms to clusters table. */
33751     +   %tmsort(data=&outclusters,
33752     +         out=&outclusters,
33753     +         by=_cluster_,
33754     +            options=,
33755     +         threads=threads);
33757     +   %tmsort(data=_desc_,
33758     +         out=_desc_,
33759     +         by=_cluster_,
33760     +            options=,
33761     +         threads=threads);
33763     +   data _desc_;
33764     +      merge &outclusters _desc_;
33765     +      by _cluster_;
33766     +   run;
33768     +   %tmsort(data=_desc_,
33769     +         out=&outclusters,
33770     +         by=_cluster_,
33771     +            options=,
33772     +         threads=threads);
33774     +   %if &algorithm=2.0 %then %do;
33776     +        %tmsort(data=&HIERDS,
33777     +         out=&HIERDS,
33778     +         by=_cluster_,
33779     +            options=,
33780     +         threads=threads);
33782     +        data &HIERds;
33783     +            merge &outCLUSTERS &HIERds (keep=_cluster_ parent level in=P);
33784     +            by _cluster_;
33785     +            clust=_cluster_;
33786     +            drop _cluster_;
33787     +            if P;
33788     +        run;
33790     +        %let empty=1;
33792     +        /* Be sure that all parent clusters are on outclusters ds */
33793     +        proc sql noprint;
33794     +            create table &outclusters as
33795     +                select a._cluster_, b.* from &hierds (rename=(clust=_CLUSTER_)) a
33796     +                left join &outclusters b
33797     +                on a._cluster_=b._cluster_;
33798     +        quit;
33800     +        %do %while (&empty);
33801     +            proc sql noprint;
33802     +                update &outclusters set freq=
33803     +                    (select sum(freq) from &HIERDS
33804     +                    where parent=_cluster_), percent=
33805     +                    (select sum(percent) from &HIERDS
33806     +                    where parent=_cluster_)
33807     +                    where freq=. and _cluster_ not in
33808     +                    (select parent from &hierds where freq=.);
33809     +                select count(*) into :empty from &outclusters
33810     +                    where freq=.;
33811     +                update &hierds set freq=(select freq from &outclusters where _cluster_=clust);
33812     +            quit;
33813     +            data &HIERds;
33814     +                merge &OUTCLUSTERS &HIERds (
33815     +                    rename=(clust=_cluster_) keep=clust parent level in=P);
33816     +                by _cluster_;
33817     +                clust=_cluster_;
33818     +                drop _cluster_;
33819     +                if P;
33820     +            run;
33821     +        %end;
33823     +        data &hierds;
33824     +            set &hierds(rename=(CLUST=_CLUSTER_) keep=clust FREQ CLUS_DESC PARENT level);
33825     +        run;
33826     +        data &outclusters;
33827     +            set &outclusters;
33828     +            if _rmsstd_ ne .;
33829     +        run;
33831     +        data &outdocs;
33832     +            set &outdocs (drop=_FINALCLUSTER_ _SUBCLUSTER_);
33833     +            label _CLUSTER_=Cluster ID;
33834     +        run;
33836     +    %end;
33838     +   %end_train_cluster:
33840     +       filename temp;
33842     +       %if &tm_debug =0  %then %do;
33843     +          proc sql nowarn noprint;
33844     +              drop table _clusstat;
33845     +              drop table _clusstat2;
33846     +              drop table _fastclusstat;
33847     +              drop table _clustermean;
33848     +              drop table _meandocs;
33849     +              drop table _rmscalc;
33850     +              drop table _rmsse;
33851     +              drop table _meanerr;
33852     +              drop table _tmutildoc;
33853     +              drop table _desc_;
33854     +              drop table _terms_;
33855     +              drop table _docs_;
33856     +              drop table _tmout_;
33857     +           quit;
33858     +       %end;
33861     +%mend;
NOTE: %INCLUDE (level 1) ending.
MPRINT(TRAIN):   filename temp catalog 'sashelp.emtxtext.tm_apply_tmutil.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTXTEXT.TM_APPLY_TMUTIL.SOURCE.
33863     + /*****************************************************************
33864     + * Copyright (C) 2009 by SAS Institute Inc., Cary, NC 27513
33865     + *
33866     + * Name:             tm_apply_tmutil.sas
33867     + * Support:          rualbr Russell Albright
33868     + * Product:
33869     + * Language:         Sas
33870     + * Script:
33871     + *
33872     + * Usage:
33873     + *
33874     + * data= out data set from tgparse
33875     + * terms= terms from tgparse
33876     + * offsets=  addoffset data set form tgparse
33877     + * docs=  data set of document id's and potentially target, not required unless target weighting is used.
33878     + * keepdocs= list of docs to keep. This is a subset of the original docs data set. Not required.
33879     + * reduceF=defaults to log(n) if not specified, eliminates terms if not in at least that many docs
33880     + *     use reduceF=1 to retain all terms.
33881     + * termweight= none, entropy, mi,
33882     + * cellweight= none, log, bin,
33883     + * synnum= Input synonym data set of _termnum_, parent ID pairs
33884     + * synchar= Input synonym data set of term,termrole, parent, parentrole. This data set will
33885     + * get converted to synnym format by the macro tm_convert_syns.
33886     + * targetvar= name of variable on doc dataset contining targetvar.
33887     + * outdata= output out dataset with no more children on this dataset
33888     + * outterms= output terms dataset with dup terms eliminated
33889     + * outweights= weight vector for the terms
33890     + * outoffsets= subsetted outtable with childterms replaced with parents
33891     + * applyweight = , indicates if the weight settings are to be applied to the output OUT table. 0 no, 1 yes.
33892     + * memloc= string for tmutil to use to store its memory pointer. Normally the default can just be used.
33893     + * keeponly=Y  If set to Y (default), then only kept terms are output in terms table.
33894     + *
33895     + * Purpose: Massage the out and key from docparse so that they can bes used
33896     + * in data mining applications.
33897     + *
33898     + * History:
33899     + *
33900     + * Notes:
33901     + *
33902     + * Last Modified By:
33903     + * Last Modified On: Tue Mar 05 16:32:57 2013
33904     + *
33905     + * End
33906     + * ************************************************************** */
33909     +%macro tm_apply_tmutil(data=, terms=,docs=,offsets=,keepdocs=,termweight=none,
33910     +                            cellweight=none,reduceF=,outdata=,outterms=,outweights=,
33911     +                            outoffsets=, synnum=,synchar=, targetvar=, applyweight = 0,
33912     +                            memloc=tmutil_loc,keeponly=Y,repOnly=N);
33913     +     %local keepdocs tempF reduceF synnum  terms  paraExist sentExist;
33916     +    %let EMEXCEPTIONSTRING=;
33917     +    %let syscc=0;
33918     +    %let systmutil=0;
33922     +    /* Find terms to drop */
33923     +        %if &keepdocs ne %then %do;
33924     +          proc sql noprint;
33925     +                create view _keepdata as
33926     +                select * from &data where _DOCUMENT_ in
33927     +                (select _DOCUMENT_ from &keepdocs);
33928     +          quit;
33929     +        %end;
33930     +          %else %do;
33932     +             proc sql noprint;
33933     +                 create view _keepdata as
33934     +                 select * from &data;
33935     +             quit;
33937     +           %let keepdocs=&docs;
33938     +        %end;
33941     +    /* set default on reduceF*/
33942     +         %if &reduceF = %then %do;
33943     +            proc sql noprint;
33944     +           select count(*) into :numdocs from &docs;
33945     +        quit;
33946     +        %let tempF = %sysfunc(log10(%eval(&numdocs+1)));
33947     +        %let reduceF= %sysfunc(floor(&tempF));
33948     +         %end;
33951     +    /* find synnum if synchar supplied */
33953     +    %if &synchar ne %then %do;
33954     +            filename temp catalog 'sashelp.emtxtext.tm_convert_syns.source';
33955     +            %include temp;
33956     +            %tm_convert_syns(insyns= &synchar, outsyns=_myOutsyns ,
33957     +                         interms=&terms,
33958     +                          outterms=newterms );
33959     +                %let numsyns=0;
33960     +                proc sql;
33961     +                   select count(*) into: numsyns
33962     +                   from _myOutsyns;
33963     +                quit;
33964     +                %if &numsyns >0 %then %do;
33965     +                   %Let synnum=_myOutsyns;
33966     +                   %let terms=newterms;
33967     +                %end;
33968     +    %end;
33969     +    /* get the out and key in the proper format*/
33970     +    proc tmutil data=_keepdata key= &terms doc=&keepdocs
33971     +        %if &targetvar ne %then target=&targetvar;
33972     +        ;
33973     +        control init memloc="&memloc";
33974     +            %if &synnum ne %then syn syndata=&synnum force;
33975     +         ;
33976     +    run;
33977     +    %if &syscc >4 %then %goto end_tm_apply_tmutil;
33978     +    %if &reduceF>1 %then %do;
33979     +           proc tmutil;
33980     +           control memloc="&memloc";
33981     +               select reduceF=&reduceF;
33982     +        run;
33983     +   %end;
33984     +    %if &syscc >4 %then %goto end_tm_apply_tmutil;
33986     +     proc tmutil;
33987     +        control memloc="&memloc" release;
33988     +        weight termwgt=&termweight cellwgt=&cellweight;
33989     +            output key=_termstmutil  keyformat=default
33990     +               %if &keeponly eq Y %then keeponly;
33991     +               %if &applyweight  eq 0 %then unweighted ;
33992     +               out=&outdata;
33993     +    run;
33994     +    %if &syscc >4 %then %goto end_tm_apply_tmutil;
33996     +    proc sql noprint;
33997     +           create table _distinctterms as
33998     +           select distinct key,term, role, attribute
33999     +           from &terms;
34001     +       create table &outterms as
34002     +       select  b.term, b.role,b.attribute ,a.*
34003     +       from _termstmutil a left join  _distinctterms b
34004     +       on a.key=b.key;
34005     +       ;
34006     +       %if &outweights ne %then %do;
34007     +          create table &outweights as
34008     +          select distinct a.key as index, a.weight as gwgt
34009     +          from &outterms(where=(_ispar in('+',' '))) a inner join
34010     +                         _distinctterms b
34011     +          on a.key =b.key;
34012     +       %end;
34014     +     quit;
34015     +     %if &offsets ne and &outoffsets ne %then %do;
34017     +        %let paraExist=0; %let sentExist=0;
34018     +        data _null_;
34019     +          dsid=open("&offsets");
34020     +          para=varnum(dsid,'_paragraph_');
34021     +          sent=varnum(dsid,'_sentence_');
34022     +          if para ge 1 then call symput('paraExist',1);
34023     +          if sent ge 1 then call symput('sentExist',1);
34024     +          run;
34027     +        proc sql noprint;
34028     +        create table &outoffsets as
34029     +           select  a._document_,
34030     +              %if &paraExist=1 %then a._paragraph_, ;
34031     +              %if &sentExist=1 %then a._sentence_,;
34032     +              a._offset_, a._length_, b.parent_id as _termnum_
34033     +                 from &offsets a, _termstmutil (where=(_ispar ne "+" and keep="Y")) b
34034     +                 where a._termnum_ = b.key;
34035     +              quit;
34036     +       %end;
34040     +     %end_tm_apply_tmutil:
34042     +     %if ^%symexist(tm_debug) %then %let tm_debug=0;
34043     +       %if &tm_debug =0  %then %do;
34044     +          proc sql noprint;
34045     +            drop table _termstmutil;
34046     +            drop table _distinctterms;
34047     +            drop view _keepdata;
34048     +            %if &synchar ne and &synnum ne  %then drop table &synnum; ;
34049     +         quit;
34050     +     %end;
34051     +     %if &syscc >4 and &systmutil > 4 %then %do;
34052     +           %let EMEXCEPTIONSTRING = EMTOOL.TMUTIL,&systmutil;
34053     +           %put emexceptionstring= "&EMEXCEPTIONSTRING";
34054     +           %let syscc=0;
34055     +     %end;
34057     +%mend;
NOTE: %INCLUDE (level 1) ending.
MPRINT(TRAIN):   filename temp catalog 'sashelp.emtxtext.tm_svd_do_samp.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTXTEXT.TM_SVD_DO_SAMP.SOURCE.
34059     +   /* ****************************************************************
34060     + * Copyright (C) 2009 by SAS Institute Inc., Cary, NC 27513
34061     + *
34062     + * Name:             tm_svd_do_samp.sas
34063     + * Product:
34064     + * Language:         Sas
34065     + * Script:
34066     + *
34067     + * Usage:
34068     + *
34069     + * data=out dataset containing only repreentative terms
34070     + * maxK= max number of dimensions to use to computer svd
34071     + * res=<high, med, low> guidenceon what number of dims to choose
34072     + * cellwgt= <none, log, binary>
34073     + * in_global= dataset with index, weight variables
34074     + * rowVar= name of the variable representing row(term)
34075     + * colVar= name of the variable representing col
34076     + * entryVar=count for row,col
34077     + * u= name of output u matrix
34078     + * v= name of output v matrix
34079     + * s= name of output s matrix
34080     + * colpro=dataset to hold projections for terms
34081     + * rowpro= datset to hold projections for docs
34082     + * normcol=<normcol> extra option to add to normalize docs
34083     + * normrow=<normrow> extra option to add to normalize terms
34084     + * docs =<document data set of ids that are being analyzed.
34085     +*      docs needs to be input explicit since some docs may have not terms
34086     + *
34087     + * Purpose: macro to run svd and compute projections, first without mpling
34088     + * and then with sampling onon.
34089     + *
34090     + * History:
34091     + *
34092     + * Notes:
34093     + *
34094     + * Last Modified By:
34095     + * Last Modified On: Thu Jan 08 17:22:43 2009
34096     + *
34097     + * End
34098     + * ************************************************************** */
34099     +%macro tm_svd_do_samp(data=,docs=,maxK=,res=,cellwgt=,in_global=,
34100     +                     rowVar=,colVar=,entryVar=,u=,v=,s=,
34101     +                     colpro=,rowpro=,normcol=, normrow=,prefix=SVD);
34103     +   %local svdkeep;
34104     +   %let syscc=0;
34105     +   proc sort data=&data; by _termnum_; run;
34107     +   proc spsvd data=&data max_k = &maxK res = &res
34108     +       local = &cellWgt global =none in_global = &in_global;
34109     +       row _termnum_;
34110     +       col _document_;
34111     +       entry _count_;
34112     +       output  u = &U v = &V s = &s;
34113     +   run;
34115     +   /*try sampling if out of memory occurred*/
34116     +   %if(&syscc eq 1111) %then %do;
34117     +      %let syscc=0; /*reset syscc*/
34118     +      proc spsvd data = &data max_k = &maxK res = &res
34119     +          local = &cellWgt global = none in_global = &in_global ;
34120     +          row &rowVar;
34121     +          col &colVar;
34122     +          entry &entryVar;
34123     +          output u = &U v = &V s = &s;
34124     +          sample allow;
34125     +      run;
34126     +   %end;
34127     +    %if &syscc > 4 %then %do;
34128     +       %let EMEXCEPTIONSTRING = EMTOOL.SPSVDERROR;
34129     +       %goto end_svd_do_samp;
34130     +    %end;
34133     +   /* if resolution is used, the matrix U/V must be truncated to the set number of dim.*/
34134     +   proc sql noprint;
34135     +       select count(*) into: svdkeep
34136     +       from &s
34137     +       where keep=1;
34138     +    quit;
34140     +    %let svdkeep=%left(&svdkeep);
34141     +    data &U;
34142     +    set &U(keep= index col1-col&svdkeep);
34143     +    run;
34145     +    data &V;
34146     +    set &V(keep= index col1-col&svdkeep);
34147     +    run;
34148     +    %if &colpro ne %then %do;
34149     +       /* when sampling weights may have wrong dimensions*/
34150     +       proc sql noprint;
34151     +          create table new_global as
34152     +             select a.*
34153     +             from &in_global a, &U b
34154     +             where a.index = b.index;
34155     +       quit;
34158     +        proc sort data=&data; by &colVar; run;
34159     +        proc spsvd data=&data IN_U=&U
34160     +            local = &cellWgt global = none in_global = new_global ;
34161     +            row &rowVar;
34162     +            col &colVar;
34163     +            entry &entryVar;
34164     +            output colpro=&colpro bigpro normcol prefix="&prefix._SVD";
34165     +        run;
34167     +        proc sort data=&docs(keep=_document_)  out=_docids;
34168     +        by _document_;
34169     +        run;
34171     +        data &colpro;
34172     +           merge &colpro _docids(rename=(_document_=index));
34173     +        by index;
34174     +        run;
34177     +        data &colpro;
34178     +          set  &colpro;
34179     +          array svd_array &prefix._SVD1 - &prefix._SVD&SVDKEEP;
34180     +          do i = 1 to dim(svd_array);
34181     +             if svd_array(i)=. then svd_array(i)=0;
34182     +          end;
34183     +          drop i;
34184     +        run;
34185     +    %end;
34187     +    %if &syscc > 4 %then %do;
34188     +       %let EMEXCEPTIONSTRING = EMTOOL.SPSVDERROR;
34189     +       %goto end_svd_do_samp;
34190     +    %end;
34192     +    %if &rowpro ne %then %do;
34193     +        proc sort data=&data; by &rowVar; run;
34194     +        /* when sampling weights may have wrong dimensions*/
34195     +       proc sql;
34196     +          create table new_global as
34197     +             select a.*
34198     +             from &in_global a, &U b
34199     +             where a.index = b.index;
34200     +       quit;
34202     +        proc spsvd data=&data IN_V=&V
34203     +            local = &cellWgt global = none in_global = new_global ;
34204     +            row &rowVar; col &colVar; entry &entryVar;
34205     +            output wordPro = &rowpro bigpro normrow prefix="&prefix._SVD";
34206     +        run;
34207     +    %end;
34209     +    %if &syscc > 4 %then %do;
34210     +       %let EMEXCEPTIONSTRING = EMTOOL.SPSVDERROR;
34211     +       %goto end_svd_do_samp;
34212     +    %end;
34214     +   %end_svd_do_samp:
34216     +%mend;
NOTE: %INCLUDE (level 1) ending.
MPRINT(TRAIN):   filename temp;
NOTE: Fileref TEMP has been deassigned.
MPRINT(TM_GET_LAST_FILTER):   * find last filter or text parse node if no filter node. ;
MPRINT(TM_GET_LAST_FILTER):   proc sql noprint;
MPRINT(TM_GET_LAST_FILTER):   select data into :last_parse_node from EMWS3.TextFilter_EMINFO where key="LastTextParsing";
MPRINT(TM_GET_LAST_FILTER):   select data into :last_filter_node from EMWS3.TextFilter_EMINFO where key="LastTextFilter";
MPRINT(TM_GET_LAST_FILTER):   select data into :last_prescore_node from EMWS3.TextFilter_EMINFO where kupcase(key)="PRESCORECODE";
MPRINT(TM_GET_LAST_FILTER):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_GET_LAST_FILTER):   * Check to make sure parse variable is present and still exists;
MPRINT(TM_GET_LAST_FILTER):   proc sql noprint;
MPRINT(TM_GET_LAST_FILTER):   select parsevar into :parsevar from EMWS3.TextFilter_tmconfig;
MPRINT(TM_GET_LAST_FILTER):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(TM_GET_LAST_FILTER):   *check for dropped parsevar on input dataset;
MPRINT(TM_GET_LAST_FILTER):   data _null_;
MPRINT(TM_GET_LAST_FILTER):   set EMWS3.TextCluster_VariableSet(where=(kupcase(NAME)="REVIEW" and USE in('Y' 'D')));
MPRINT(TM_GET_LAST_FILTER):   if (ROLE='TEXT' or ROLE='TEXTLOC') then call symput('parsevarOK', strip(ROLE));
MPRINT(TM_GET_LAST_FILTER):   run;

NOTE: There were 1 observations read from the data set EMWS3.TEXTCLUSTER_VARIABLESET.
      WHERE (KUPCASE(NAME)='REVIEW') and USE in ('D', 'Y');
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   data EMWS3.TextCluster_last_tm_nodes;
MPRINT(TRAIN):   set EMWS3.TextFilter_EMINFO;
MPRINT(TRAIN):   run;

NOTE: There were 5 observations read from the data set EMWS3.TEXTFILTER_EMINFO.
NOTE: The data set EMWS3.TEXTCLUSTER_LAST_TM_NODES has 5 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   data _null_;
MPRINT(TRAIN):   set EMWS3.TextCluster_VariableSet(where=(ROLE='TARGET' and USE in('Y' 'D') and LEVEL ne 'INTERVAL'));
MPRINT(TRAIN):   if _N_=1 then call symput('targetvar', strip(NAME));
MPRINT(TRAIN):   run;

NOTE: There were 0 observations read from the data set EMWS3.TEXTCLUSTER_VARIABLESET.
      WHERE (ROLE='TARGET') and USE in ('D', 'Y') and (LEVEL not = 'INTERVAL');
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   proc sql noprint;
MPRINT(TRAIN):   create table EMWS3.TextCluster_tmconfig as select * from EMWS3.TextFilter_tmconfig;
NOTE: Table EMWS3.TEXTCLUSTER_TMCONFIG created, with 1 rows and 29 columns.

MPRINT(TRAIN):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   proc sql noprint;
MPRINT(TRAIN):   select cellwgt into: _cellweight from EMWS3.TextCluster_tmconfig;
MPRINT(TRAIN):   select termwgt into: _termwgt from EMWS3.TextCluster_tmconfig;
MPRINT(TRAIN):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   data _keepdocs (keep=_DOCUMENT_ );
MPRINT(TRAIN):   set EMWS3.TextFilter_TRAIN;
MPRINT(TRAIN):   run;

NOTE: There were 4400 observations read from the data set EMWS3.TEXTPARSING_TRAIN.
NOTE: There were 100 observations read from the data set EMWS3.TEXTFILTER_DOC_IDS.
NOTE: There were 100 observations read from the data set EMWS3.TEXTFILTER_TRAIN.
NOTE: The data set WORK._KEEPDOCS has 100 observations and 1 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TM_APPLY_TMUTIL):   proc sql noprint;
MPRINT(TM_APPLY_TMUTIL):   create view _keepdata as select * from EMWS3.TextFilter_tmout where _DOCUMENT_ in (select _DOCUMENT_ from _keepdocs);
NOTE: SQL view WORK._KEEPDATA has been defined.
MPRINT(TM_APPLY_TMUTIL):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_APPLY_TMUTIL):   proc tmutil data=_keepdata key= EMWS3.TextFilter_terms doc=_keepdocs ;
MPRINT(TM_APPLY_TMUTIL):   control init memloc="_tmmem";
MPRINT(TM_APPLY_TMUTIL):   ;
MPRINT(TM_APPLY_TMUTIL):   run;

NOTE: There were 504 observations read from the data set EMWS3.TEXTFILTER_TMOUT.
NOTE: There were 100 observations read from the data set WORK._KEEPDOCS.
NOTE: There were 504 observations read from the data set WORK._KEEPDATA.
NOTE: There were 204 observations read from the data set EMWS3.TEXTFILTER_TERMS_DATA.
      WHERE KEEP='Y';
NOTE: There were 7276 observations read from the data set EMWS3.TEXTFILTER_TERM_STRINGS.
NOTE: There were 100 observations read from the data set WORK._KEEPDOCS.
NOTE: PROCEDURE TMUTIL used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(TM_APPLY_TMUTIL):   proc tmutil;
MPRINT(TM_APPLY_TMUTIL):   control memloc="_tmmem";
MPRINT(TM_APPLY_TMUTIL):   select reduceF=2;
MPRINT(TM_APPLY_TMUTIL):   run;

NOTE: PROCEDURE TMUTIL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_APPLY_TMUTIL):   proc tmutil;
MPRINT(TM_APPLY_TMUTIL):   control memloc="_tmmem" release;
MPRINT(TM_APPLY_TMUTIL):   weight termwgt=ENTROPY cellwgt=LOG;
MPRINT(TM_APPLY_TMUTIL):   output key=_termstmutil keyformat=default keeponly unweighted out=_outtmutil_;
MPRINT(TM_APPLY_TMUTIL):   run;

NOTE: The data set WORK._TERMSTMUTIL has 204 observations and 8 variables.
NOTE: The data set WORK._OUTTMUTIL_ has 498 observations and 3 variables.
NOTE: PROCEDURE TMUTIL used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(TM_APPLY_TMUTIL):   proc sql noprint;
MPRINT(TM_APPLY_TMUTIL):   create table _distinctterms as select distinct key,term, role, attribute from EMWS3.TextFilter_terms;
NOTE: Table WORK._DISTINCTTERMS created, with 170 rows and 4 columns.

MPRINT(TM_APPLY_TMUTIL):   create table _newkey as select b.term, b.role,b.attribute ,a.* from _termstmutil a left join _distinctterms b on a.key=b.key;
NOTE: Table WORK._NEWKEY created, with 204 rows and 11 columns.

MPRINT(TM_APPLY_TMUTIL):   ;
MPRINT(TM_APPLY_TMUTIL):   create table _weights as select distinct a.key as index, a.weight as gwgt from _newkey(where=(_ispar in('+',' '))) a inner join _distinctterms b on a.key =b.key;
NOTE: Table WORK._WEIGHTS created, with 40 rows and 2 columns.

MPRINT(TM_APPLY_TMUTIL):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TM_SVD_DO_SAMP):   proc sort data=_outtmutil_;
MPRINT(TM_SVD_DO_SAMP):   by _termnum_;
MPRINT(TM_SVD_DO_SAMP):   run;

NOTE: There were 498 observations read from the data set WORK._OUTTMUTIL_.
NOTE: The data set WORK._OUTTMUTIL_ has 498 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_SVD_DO_SAMP):   proc spsvd data=_outtmutil_ max_k = 100 res = LOW local = LOG global =none in_global = _weights;
MPRINT(TM_SVD_DO_SAMP):   row _termnum_;
MPRINT(TM_SVD_DO_SAMP):   col _document_;
MPRINT(TM_SVD_DO_SAMP):   entry _count_;
MPRINT(TM_SVD_DO_SAMP):   output u = EMWS3.TextCluster_svd_u v = _svdv s = EMWS3.TextCluster_svd_s;
MPRINT(TM_SVD_DO_SAMP):   run;

NOTE: P has been set to 4.
NOTE: Restart 1, Converged 12
NOTE: Restart 2, Converged 20
NOTE: Singular values have converged.  Creating data sets.
NOTE: Restarted 2 times.
NOTE: Using value of 12 for K.
NOTE: There were 498 observations read from the data set WORK._OUTTMUTIL_.
NOTE: There were 40 observations read from the data set WORK._WEIGHTS.
NOTE: The data set EMWS3.TEXTCLUSTER_SVD_U has 40 observations and 35 variables.
NOTE: The data set WORK._SVDV has 97 observations and 35 variables.
NOTE: The data set EMWS3.TEXTCLUSTER_SVD_S has 34 observations and 2 variables.
NOTE: PROCEDURE SPSVD used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_SVD_DO_SAMP):   proc sql noprint;
MPRINT(TM_SVD_DO_SAMP):   select count(*) into: svdkeep from EMWS3.TextCluster_svd_s where keep=1;
MPRINT(TM_SVD_DO_SAMP):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(TM_SVD_DO_SAMP):   data EMWS3.TextCluster_svd_u;
MPRINT(TM_SVD_DO_SAMP):   set EMWS3.TextCluster_svd_u(keep= index col1-col12);
MPRINT(TM_SVD_DO_SAMP):   run;

NOTE: There were 40 observations read from the data set EMWS3.TEXTCLUSTER_SVD_U.
NOTE: The data set EMWS3.TEXTCLUSTER_SVD_U has 40 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_SVD_DO_SAMP):   data _svdv;
MPRINT(TM_SVD_DO_SAMP):   set _svdv(keep= index col1-col12);
MPRINT(TM_SVD_DO_SAMP):   run;

NOTE: There were 97 observations read from the data set WORK._SVDV.
NOTE: The data set WORK._SVDV has 97 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_SVD_DO_SAMP):   proc sql noprint;
MPRINT(TM_SVD_DO_SAMP):   create table new_global as select a.* from _weights a, EMWS3.TextCluster_svd_u b where a.index = b.index;
NOTE: Table WORK.NEW_GLOBAL created, with 40 rows and 2 columns.

MPRINT(TM_SVD_DO_SAMP):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(TM_SVD_DO_SAMP):   proc sort data=_outtmutil_;
MPRINT(TM_SVD_DO_SAMP):   by _document_;
MPRINT(TM_SVD_DO_SAMP):   run;

NOTE: There were 498 observations read from the data set WORK._OUTTMUTIL_.
NOTE: The data set WORK._OUTTMUTIL_ has 498 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_SVD_DO_SAMP):   proc spsvd data=_outtmutil_ IN_U=EMWS3.TextCluster_svd_u local = LOG global = none in_global = new_global ;
MPRINT(TM_SVD_DO_SAMP):   row _termnum_;
MPRINT(TM_SVD_DO_SAMP):   col _document_;
MPRINT(TM_SVD_DO_SAMP):   entry _count_;
MPRINT(TM_SVD_DO_SAMP):   output colpro=_svdcolpro bigpro normcol prefix="TextCluster_SVD";
MPRINT(TM_SVD_DO_SAMP):   run;

NOTE: There were 498 observations read from the data set WORK._OUTTMUTIL_.
NOTE: There were 40 observations read from the data set EMWS3.TEXTCLUSTER_SVD_U.
NOTE: There were 40 observations read from the data set WORK.NEW_GLOBAL.
NOTE: The data set WORK._SVDCOLPRO has 97 observations and 13 variables.
NOTE: PROCEDURE SPSVD used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_SVD_DO_SAMP):   proc sort data=_keepdocs(keep=_document_) out=_docids;
MPRINT(TM_SVD_DO_SAMP):   by _document_;
MPRINT(TM_SVD_DO_SAMP):   run;

NOTE: There were 100 observations read from the data set WORK._KEEPDOCS.
NOTE: The data set WORK._DOCIDS has 100 observations and 1 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_SVD_DO_SAMP):   data _svdcolpro;
MPRINT(TM_SVD_DO_SAMP):   merge _svdcolpro _docids(rename=(_document_=index));
MPRINT(TM_SVD_DO_SAMP):   by index;
MPRINT(TM_SVD_DO_SAMP):   run;

NOTE: There were 97 observations read from the data set WORK._SVDCOLPRO.
NOTE: There were 100 observations read from the data set WORK._DOCIDS.
NOTE: The data set WORK._SVDCOLPRO has 100 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_SVD_DO_SAMP):   data _svdcolpro;
MPRINT(TM_SVD_DO_SAMP):   set _svdcolpro;
MPRINT(TM_SVD_DO_SAMP):   array svd_array TextCluster_SVD1 - TextCluster_SVD12;
MPRINT(TM_SVD_DO_SAMP):   do i = 1 to dim(svd_array);
MPRINT(TM_SVD_DO_SAMP):   if svd_array(i)=. then svd_array(i)=0;
MPRINT(TM_SVD_DO_SAMP):   end;
MPRINT(TM_SVD_DO_SAMP):   drop i;
MPRINT(TM_SVD_DO_SAMP):   run;

NOTE: There were 100 observations read from the data set WORK._SVDCOLPRO.
NOTE: The data set WORK._SVDCOLPRO has 100 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_SVD_DO_SAMP):   proc sort data=_outtmutil_;
MPRINT(TM_SVD_DO_SAMP):   by _termnum_;
MPRINT(TM_SVD_DO_SAMP):   run;

NOTE: There were 498 observations read from the data set WORK._OUTTMUTIL_.
NOTE: The data set WORK._OUTTMUTIL_ has 498 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(TM_SVD_DO_SAMP):   proc sql;
MPRINT(TM_SVD_DO_SAMP):   create table new_global as select a.* from _weights a, EMWS3.TextCluster_svd_u b where a.index = b.index;
NOTE: Table WORK.NEW_GLOBAL created, with 40 rows and 2 columns.

MPRINT(TM_SVD_DO_SAMP):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_SVD_DO_SAMP):   proc spsvd data=_outtmutil_ IN_V=_svdv local = LOG global = none in_global = new_global ;
MPRINT(TM_SVD_DO_SAMP):   row _termnum_;
MPRINT(TM_SVD_DO_SAMP):   col _document_;
MPRINT(TM_SVD_DO_SAMP):   entry _count_;
MPRINT(TM_SVD_DO_SAMP):   output wordPro = _svdrowpro bigpro normrow prefix="TextCluster_SVD";
MPRINT(TM_SVD_DO_SAMP):   run;

NOTE: There were 498 observations read from the data set WORK._OUTTMUTIL_.
NOTE: There were 97 observations read from the data set WORK._SVDV.
NOTE: There were 40 observations read from the data set WORK.NEW_GLOBAL.
NOTE: The data set WORK._SVDROWPRO has 40 observations and 13 variables.
NOTE: PROCEDURE SPSVD used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   proc sql noprint;
MPRINT(TRAIN):   create table EMWS3.TextCluster_terms(drop=index) as select a.*,b.* from EMWS3.TextFilter_terms a left join _svdrowpro b on a.key = b.index;
NOTE: Table EMWS3.TEXTCLUSTER_TERMS created, with 204 rows and 25 columns.

MPRINT(TRAIN):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_CLUSTER):   filename temp catalog 'sashelp.emtext.tmgetncl.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTEXT.TMGETNCL.SOURCE.
34219     +
34220     + /*
34221     +  Macro:   tmgetncl.sas
34222     +  Purpose: To obtain a default number of clusters
34223     +  Syntax:  %tmgetncl(data=, maxclusters=, vars=);
34224     +
34225     +  Required Parameters:  data=      The input data set.
34226     +
34227     +  Optional Parameters:  vars=      Variables to be used
34228     +
34229     +  History:
34230     +  2001/01/23 - Bill Wheeler - Initial Coding.
34231     +
34232     +*/
34233     + %MACRO tmgetncl(data=, maxclusters=, vars=, tempDS=,
34234     +                 clusDS=, threads=THREADS);
34235     +
34236     +  %if &maxclusters= %then %let maxclusters = 40;
34237     +
34238     +  %if &vars ^= %then %let var = var &vars;
34239     +  %else %let var = ;
34240     +
34241     +  /* run PROC FASTCLUS with maxClusters clusters */
34242     +  proc fastclus data = &data noprint
34243     +    maxclusters = &maxclusters
34244     +    mean = &tempDS;
34245     +    &var
34246     +    ;
34247     +    run;
34248     +
34249     +  /* use PROC CLUSTER with the MEAN data set from FASTCLUS */
34250     +  proc cluster data = &tempDS
34251     +    method = WARD
34252     +    pseudo
34253     +    noprint
34254     +    outtree = &tempDS;
34255     +    &var;
34256     +  run;
34257     +
34258     +  %if (&SYSERR > 4) %then %do;
34259     +    data &clusDS; nclus = 0; run;
34260     +    %goto exit;
34261     +  %end;
34262     +
34263     +  /* sort and get rid of missing values in the outtree data set */
34264     +  %tmsort(data=&tempDS(where=(_ccc_ > -99999.0) keep = _ncl_ _ccc_),
34265     +        out=&tempDS, by=_ncl_, options=, threads=&threads);
34266     +
34267     +  data &clusDS; set &tempDS;
34268     +    keep nclus;
34269     +    retain loclclus -1 loclccc 0 maxccc 0 maxclus 0
34270     +   jclus -1 maxjump -1 nclus 0 jccc 0 prevjump 0 jump 0 occc 0 oncl 0;
34271     +
34272     +   if _N_ = 1 then do;
34273     +     maxccc = _ccc_;
34274     +     maxclus = _ncl_;
34275     +     nclus = _ncl_;
34276     +     occc = _ccc_;
34277     +     oncl = _ncl_;
34278     +   end;
34279     +   else if (_N_ = 2) then do;
34280     +     jump = _ccc_ - occc;
34281     +     if (jump > 0) then do;
34282     +       maxjump = jump;
34283     +       jclus = _ncl_;
34284     +     end;
34285     +     if (_ccc_ > maxccc) then do;
34286     +       maxccc = _ccc_;
34287     +       maxclus = _ncl_;
34288     +     end;
34289     +     occc = _ccc_;
34290     +     oncl = _ncl_;
34291     +   end;
34292     +
34293     +   else if (_N_ > 2) then do;
34294     +     prevjump = jump;
34295     +     jump = _ccc_ - occc;
34296     +
34297     +     if ((prevjump > 0) & (jump < 0) & (loclclus < 0)) then do;
34298     +        loclclus = oncl;
34299     +        loclccc = occc;
34300     +     end;
34301     +     if (_ccc_ > maxccc) then do;
34302     +       maxccc = _ccc_;
34303     +       maxclus = _ncl_;
34304     +     end;
34305     +     if ((jump > 0) & (jump > maxjump)) then do;
34306     +       jclus = _ncl_;
34307     +       maxjump = jump;
34308     +       jccc = _ccc_;
34309     +     end;
34310     +
34311     +     occc = _ccc_;
34312     +     oncl = _ncl_;
34313     +
34314     +     if ((loclclus > 0) & (jclus > 0)) then nclus = MIN(loclclus, jclus);
34315     +     else if (loclclus > 0) then nclus = loclclus;
34316     +     else if (jclus > 0) then nclus = jclus;
34317     +     else nclus = maxclus;
34318     +   end;
34319     +  run;
34320     +
34321     +  %exit: ;
34322     +
34323     +%MEND tmgetncl;
NOTE: %INCLUDE (level 1) ending.
MPRINT(TM_CLUSTER):   filename temp catalog 'sashelp.emtext.tmfast.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTEXT.TMFAST.SOURCE.
34324     + /*
34325     +
34326     +  Macro:   tmfast.sas
34327     +  Purpose: Call proc fastclus with given defaults and parameters.
34328     +  Syntax:  %tmfast(data=, clusters=, outstat=, vars=);
34329     +
34330     +  Required Parameters:  data=      The input data set.
34331     +                        clusters=  The maximum number of clusters
34332     +
34333     +  Optional Parameters:  vars=      Variables to be used
34334     +                        outstat=   The name of the OUTSTAT data set
34335     +                        outseed=   The name of the OUTSEED data set
34336     +
34337     +  Either outstat or outseed mut be given, but not both.
34338     +  History:
34339     +  2001/01/16 - Bill Wheeler - Initial Coding.
34340     +
34341     +*/
34342     +%MACRO tmfast(data=, clusters=, outstat=, outseed=,
34343     +                 id=, out=, vars=);
34344     + /* defaults */
34345     + %if (&id ne ) %then %let id = id &id;
34346     + %if (&out ne ) %then %let out = out = &out;
34347     + %if (&vars ne ) %then %let var = var &vars;
34348     + %else %let var = ;
34349     +
34350     + %if &outseed= %then
34351     + %do;
34352     +   proc fastclus data = &data
34353     +   maxclusters = &clusters noprint
34354     +   outstat = &outstat &out;
34355     +   &var;
34356     +   &id;
34357     + %end;
34358     + %else
34359     + %do;
34360     +   proc fastclus data = &data
34361     +   maxclusters = &clusters noprint
34362     +   outseed = &outseed &out;
34363     +   &var;
34364     +   &id;
34365     + %end;
34366     +%MEND tmfast;
NOTE: %INCLUDE (level 1) ending.
MPRINT(TM_CLUSTER):   filename temp catalog 'sashelp.emtext.tmemclus.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTEXT.TMEMCLUS.SOURCE.
34367     +
34368     + /*
34369     +
34370     +  Macro:   tmemclus.sas
34371     +  Purpose: Call proc emclus with given defaults and parameters.
34372     +  Syntax:  %tmemclus(data=, role=, clusters=, seed=,
34373     +                   outstat=, out=, vars=, cov=, iter=, secclus=,
34374     +                   seciter=, min=, method=, eps=, init=, print=,
34375     +                   p=, outliers=, decvar=, initstd=, dist=,
34376     +                   secstd=, nobs=, threads=);
34377     +  Required Parameters:  data=      The input data set.
34378     +                        role=      Train or score
34379     +                        clusters=  The number of primary clusters
34380     +
34381     +  Optional Parameters:  vars=      Variables to be used
34382     +                   cov=       Type of covariance matrix
34383     +                   iter=      Number of EM iterations
34384     +                   secclus    Number of secondary clusters
34385     +                   seciter    Number of k-means iterations
34386     +                   min=       Minimum number of obs in a cluster
34387     +                   method=    Standard or scaled
34388     +                   eps=       Stopping tolerance
34389     +                   init=      Random, Fastclus, or Emclus
34390     +                   print=     All, last, or none
34391     +                   p=
34392     +                   outliers=  Keep, cluster, or ignore
34393     +                   outstat=   Name of OUTSTAT data set
34394     +                   out=       Name of OUT data set
34395     +                   seed=      Name of SEED data set
34396     +                   decvar=    Proportion to decrease variances
34397     +                   initstd=   Initial standard deviation
34398     +                   dist=      Minimum distance between clusters
34399     +                   secstd=    Secondary cluster max std dev.
34400     +                   nobs=      Number of obs read in each iteration
34401     +  History:
34402     +  2001/01/16 - Bill Wheeler - Initial Coding.
34403     +  2001/11/29 - Bill Wheeler - Updated for version 8 or 9
34404     +*/
34405     +%MACRO tmemclus(data=, role=, clusters=, seed=,
34406     + outstat=, out=, vars=, cov=, iter=, secclus=,
34407     + seciter=, min=, method=, eps=, init=, print=,
34408     + p=, outliers=, decvar=, initstd=, dist=, secstd=, nobs=, threads=);
34409     +
34410     + %local saveout saveseed op1 op2 op3 op4;
34411     +
34412     + %LET saveout = &out;
34413     + %LET saveseed = &outstat;
34414     +
34415     + /* defaults */
34416     + %if &role= %then %let role = TRAIN;
34417     + %if &seed ne %then %let seed = seed=&seed;
34418     + %if &vars= %then %let var = ;
34419     + %else %let var = var &vars;
34420     + %if &cov ne %then %let cov = cov = &cov;
34421     + %if &iter ne %then %let iter = iter = &iter;
34422     + %if &init ne %then %let init = init = &init;
34423     + %if &eps ne  %then %let eps = eps = &eps;
34424     + %if &min ne %then %let min = min = &min;
34425     + %if &seciter ne %then %let seciter = seciter = &seciter;
34426     + %if &print ne %then %let print = print = &print;
34427     + %if &p ne %then %let p = p = &p;
34428     + %if &outliers ne %then %let outliers = outliers = &outliers;
34429     + %if &method ne %then %let method = method = &method;
34430     + %if &decvar ne %then %let decvar = decvar = &decvar;
34431     + %if &outstat ne %then %let outstat = outstat = &outstat;
34432     + %if &out ne %then %let out = out = &out;
34433     + %if (&threads >= 0)  %then %let threads = threads = &threads;
34434     + %else %let threads = ;
34435     +
34436     + %LET op1 = ;
34437     + %LET op2 = ;
34438     + %LET op3 = ;
34439     + %LET op4 = ;
34440     + %if ^(&initstd=) %then %let op1 = %str(initstd = &initstd);
34441     + %if ^(&dist=) %then %let op2 = %str(dist = &dist);
34442     + %if ^(&secstd=) %then %let op3 = %str(secstd = &secstd);
34443     + %if ^(&nobs=) %then %let op4 = %str(nobs = &nobs);
34444     +
34445     +
34446     + %IF &SYSVER < 9 %THEN %DO;
34447     +    %LET cov = ;
34448     +    %LET decvar = ;
34449     +    %LET outliers = ;
34450     +    %LET out = ;
34451     + %END;
34452     +
34453     +
34454     + %if %upcase(&role) = TRAIN %then
34455     + %do;
34456     +   proc emclus data = &data
34457     +   clusters = &clusters
34458     +   &seed
34459     +   &outstat
34460     +   &out
34461     +   &init
34462     +   &eps
34463     +   &method
34464     +   &secclus
34465     +   &min
34466     +   &print
34467     +   &outliers
34468     +   &iter
34469     +   &op1 &op2
34470     +   &op3 &op4
34471     +   &decvar
34472     +   &cov
34473     +   &threads
34474     +   ;
34475     +   &var;
34476     + %end;
34477     + %else
34478     +  %do;
34479     +    proc emclus data = &data
34480     +    role = score
34481     +    clusters = &clusters
34482     +    &seed
34483     +    &out
34484     +    &cov
34485     +    ;
34486     +    &var;
34487     +  %end;
34488     +
34489     + %IF &SYSVER < 9 and &saveout ^= %THEN %DO;
34490     +   proc emclus data = &data
34491     +   role = score
34492     +   clusters = &clusters
34493     +   seed = &saveseed
34494     +   &saveout
34495     +   ;
34496     +   &var;
34497     + %END;
34498     +
34499     +
34500     +%MEND tmemclus;
NOTE: %INCLUDE (level 1) ending.
MPRINT(TM_CLUSTER):   filename temp catalog 'sashelp.emtext.tmpred.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTEXT.TMPRED.SOURCE.
34501     +
34502     +/*
34503     +  Macro: tmpred(inds,outds,clusters,type=,ignore=,freqDS=)
34504     +
34505     +  Description: This macro will take output from
34506     +     emclus and generate predicted
34507     +      predicted clusters.
34508     +
34509     +  Parms: inds - input data set, produced by emclus.
34510     +   outds - data set with clusters created by this macro.
34511     +   clusters - number of clusters that should be on this data set
34512     +   type - valid values: 'max' or 'prob'.  Max will just take the
34513     +      cluster with the highest probability as the predicted cluster.
34514     +      In the case of a tie the first cluster with that value will
34515     +       selected.
34516     +      Prob will attempt to select multiple clusters based on
34517     +      how many clusters were requested.  That is if 3 clusters
34518     +      were requested, any cluster with prob>1/3 will be selected
34519     +      as the predicted cluster. THIS OPTION IS UNTESTED.
34520     +*/
34521     +
34522     +%macro tmpred(inds,outds,clusters,type=, ignore=0, freqDS=, compress=1);
34523     +
34524     +  %local _str newfreqDS _flag;
34525     +
34526     +  * set the optional arguments;
34527     +  %if &type= %then %let type=max;
34528     +  %if &ignore = 1 %then %let
34529     +    _str = if _CLUSTER_ = &clusters then _CLUSTER_ = .;
34530     +  %else %let _str = ;
34531     +  %if %str(&freqDS) ^= %str() %then %do;
34532     +   %let newfreqDS = &freqDS(keep=_c1-_c&clusters);
34533     +   %let _flag = 1;
34534     +  %end;
34535     +  %else %let _flag = 0;
34536     +
34537     +  %if &compress = 1 %then %let compress = compress=Y;
34538     +  %else %let compress = ;
34539     +
34540     +  data &outds(&compress drop=_c1-_c&clusters)
34541     +    %if &_flag = 1 %then %do;
34542     +    &newfreqDS
34543     +    %end;
34544     +    ;
34545     +    set &inds end=eof;
34546     +   * array for holding all probabilities;
34547     +    array _p prob1--prob&clusters;
34548     +    array _c(&clusters);
34549     +    retain _c 0;
34550     +   * get rid of working columns;
34551     +    drop _max_ _i /*prob1--prob&clusters*/ _WARN_;
34552     +    /* keep the largest probability and the cluster */
34553     +    _max_ = 0;
34554     +    do _i = 1 to &clusters;
34555     +      if _p(_i) > _max_ then do;
34556     +        _max_ = _p(_i);
34557     +        _CLUSTER_ = _i;
34558     +      end;
34559     +    end;
34560     +    if (_CLUSTER_ >= 1) and (_CLUSTER_ <= &clusters) then
34561     +      _c(_CLUSTER_) = _c(_CLUSTER_) + 1;
34562     +    else _CLUSTER_ = .;
34563     +    &_str;
34564     +    %if &_flag = 1 %then %do;
34565     +      if eof then do;
34566     +        output &freqDS;
34567     +                output &outDS;
34568     +          end;
34569     +          else output &outDS;
34570     +        %end;
34571     +
34572     +    run;
34573     +%mend tmpred;
NOTE: %INCLUDE (level 1) ending.
MPRINT(TM_CLUSTER):   filename temp catalog 'sashelp.emtext.tmsort.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTEXT.TMSORT.SOURCE.
34574     + /*
34575     +PROC SORT macro
34576     +
34577     +%tmsort(data=, out=, by=);
34578     +
34579     +data=      - name of input data set (outtree data set from PROC CLUSTER)
34580     +out=       - name of the output data set
34581     +by=        - by statement
34582     +options=   - proc options
34583     +*/
34584     +
34585     +%macro tmsort(data=, out=, by=, options=, threads=THREADS);
34586     +  %if %BQUOTE(&out) ^= %then %let out = out =  &out;
34587     +  %if &SYSVER < 9 %then %let threads = ;
34588     +
34589     +  proc sort data = %STR(&data) &threads &options
34590     +    &out;
34591     +    by &by;
34592     +  run;
34593     +
34594     +%mend tmsort;
NOTE: %INCLUDE (level 1) ending.
MPRINT(TM_CLUSTER):   proc sql noprint;
MPRINT(TM_CLUSTER):   select count(*) into: numTerms from EMWS3.TextFilter_terms a where a.numdocs>=2 and _ispar in('+',' ') ;
MPRINT(TM_CLUSTER):   select count (*) into: numdocs from EMWS3.TextFilter_TRAIN a;
MPRINT(TM_CLUSTER):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(TMGETNCL):   proc fastclus data = _svdcolpro noprint maxclusters = 40 mean = _clusTemp1;
MPRINT(TMGETNCL):   var TextCluster_SVD1 - TextCluster_SVD12 ;
MPRINT(TMGETNCL):   run;

NOTE: The data set WORK._CLUSTEMP1 has 40 observations and 19 variables.
NOTE: PROCEDURE FASTCLUS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TMGETNCL):   proc cluster data = _clusTemp1 method = WARD pseudo noprint outtree = _clusTemp1;
MPRINT(TMGETNCL):   var TextCluster_SVD1 - TextCluster_SVD12;
MPRINT(TMGETNCL):   run;

NOTE: The data set WORK._CLUSTEMP1 has 79 observations and 28 variables.
NOTE: PROCEDURE CLUSTER used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TMSORT):   proc sort data = _clusTemp1(where=(_ccc_ > -99999.0) keep = _ncl_ _ccc_) out = _clusTemp1;
MPRINT(TMSORT):   by _ncl_;
MPRINT(TMSORT):   run;

NOTE: There were 20 observations read from the data set WORK._CLUSTEMP1.
      WHERE _ccc_>-99999;
NOTE: The data set WORK._CLUSTEMP1 has 20 observations and 2 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TMGETNCL):  ;
MPRINT(TMGETNCL):   data _clusTemp;
MPRINT(TMGETNCL):   set _clusTemp1;
MPRINT(TMGETNCL):   keep nclus;
MPRINT(TMGETNCL):   retain loclclus -1 loclccc 0 maxccc 0 maxclus 0 jclus -1 maxjump -1 nclus 0 jccc 0 prevjump 0 jump 0 occc 0 oncl 0;
MPRINT(TMGETNCL):   if _N_ = 1 then do;
MPRINT(TMGETNCL):   maxccc = _ccc_;
MPRINT(TMGETNCL):   maxclus = _ncl_;
MPRINT(TMGETNCL):   nclus = _ncl_;
MPRINT(TMGETNCL):   occc = _ccc_;
MPRINT(TMGETNCL):   oncl = _ncl_;
MPRINT(TMGETNCL):   end;
MPRINT(TMGETNCL):   else if (_N_ = 2) then do;
MPRINT(TMGETNCL):   jump = _ccc_ - occc;
MPRINT(TMGETNCL):   if (jump > 0) then do;
MPRINT(TMGETNCL):   maxjump = jump;
MPRINT(TMGETNCL):   jclus = _ncl_;
MPRINT(TMGETNCL):   end;
MPRINT(TMGETNCL):   if (_ccc_ > maxccc) then do;
MPRINT(TMGETNCL):   maxccc = _ccc_;
MPRINT(TMGETNCL):   maxclus = _ncl_;
MPRINT(TMGETNCL):   end;
MPRINT(TMGETNCL):   occc = _ccc_;
MPRINT(TMGETNCL):   oncl = _ncl_;
MPRINT(TMGETNCL):   end;
MPRINT(TMGETNCL):   else if (_N_ > 2) then do;
MPRINT(TMGETNCL):   prevjump = jump;
MPRINT(TMGETNCL):   jump = _ccc_ - occc;
MPRINT(TMGETNCL):   if ((prevjump > 0) & (jump < 0) & (loclclus < 0)) then do;
MPRINT(TMGETNCL):   loclclus = oncl;
MPRINT(TMGETNCL):   loclccc = occc;
MPRINT(TMGETNCL):   end;
MPRINT(TMGETNCL):   if (_ccc_ > maxccc) then do;
MPRINT(TMGETNCL):   maxccc = _ccc_;
MPRINT(TMGETNCL):   maxclus = _ncl_;
MPRINT(TMGETNCL):   end;
MPRINT(TMGETNCL):   if ((jump > 0) & (jump > maxjump)) then do;
MPRINT(TMGETNCL):   jclus = _ncl_;
MPRINT(TMGETNCL):   maxjump = jump;
MPRINT(TMGETNCL):   jccc = _ccc_;
MPRINT(TMGETNCL):   end;
MPRINT(TMGETNCL):   occc = _ccc_;
MPRINT(TMGETNCL):   oncl = _ncl_;
MPRINT(TMGETNCL):   if ((loclclus > 0) & (jclus > 0)) then nclus = MIN(loclclus, jclus);
MPRINT(TMGETNCL):   else if (loclclus > 0) then nclus = loclclus;
MPRINT(TMGETNCL):   else if (jclus > 0) then nclus = jclus;
MPRINT(TMGETNCL):   else nclus = maxclus;
MPRINT(TMGETNCL):   end;
MPRINT(TMGETNCL):   run;

NOTE: There were 20 observations read from the data set WORK._CLUSTEMP1.
NOTE: The data set WORK._CLUSTEMP has 20 observations and 1 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TMGETNCL):   ;
MPRINT(TM_CLUSTER):  ;
MPRINT(TM_CLUSTER):   proc sql noprint;
MPRINT(TM_CLUSTER):   select max(nclus) into: numClus from _clusTemp ;
MPRINT(TM_CLUSTER):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_CLUSTER):   proc sql noprint;
MPRINT(TM_CLUSTER):   select count(*) into: nobs from _svdcolpro;
MPRINT(TM_CLUSTER):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TMFAST):   proc fastclus data = _svdcolpro maxclusters = 12 noprint outstat = _fastclusstat ;
MPRINT(TMFAST):   var TextCluster_SVD1 - TextCluster_SVD12;
MPRINT(TMFAST):   ;
MPRINT(TM_CLUSTER):  ;
MPRINT(TM_CLUSTER):   run;

NOTE: The data set WORK._FASTCLUSSTAT has 70 observations and 15 variables.
NOTE: PROCEDURE FASTCLUS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_CLUSTER):   proc sql noprint;
MPRINT(TM_CLUSTER):   select max(CLUSTER) into :numClus from _fastclusstat where upcase(_TYPE_)='SEED' ;
MPRINT(TM_CLUSTER):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(TMEMCLUS):   proc emclus data = _svdcolpro clusters = 12 seed=_fastclusstat outstat = EMWS3.TextCluster_emoutstat out = _tmutildoc init = FASTCLUS eps = .1 print = NONE iter = 5 decvar = 0 ;
MPRINT(TMEMCLUS):   var TextCluster_SVD1 - TextCluster_SVD12;
MPRINT(TM_CLUSTER):  ;
MPRINT(TM_CLUSTER):   run;

NOTE: The standard EM algorithm will be run.
NOTE: DIST is set to 0.2510792851
NOTE: EPS is set to 0.1
NOTE: INITSTD is set to 26.768098673
NOTE: ITER is set to 5
NOTE: MAXTIME is set to 2147483647
WARNING: The maximum number of 5 iterations in the EM algorithm has been reached. Parameter estimates may not be accurate.
NOTE: There were 100 observations read from the data set WORK._SVDCOLPRO.
NOTE: There were 70 observations read from the data set WORK._FASTCLUSSTAT.
NOTE: The data set EMWS3.TEXTCLUSTER_EMOUTSTAT has 25 observations and 19 variables.
NOTE: The data set WORK._TMUTILDOC has 100 observations and 26 variables.
NOTE: PROCEDURE EMCLUS used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(TMPRED):   * set the optional arguments;
MPRINT(TMPRED):   data EMWS3.TextCluster_docs(compress=Y drop=_c1-_c12) _clusstat(keep=_c1-_c12) ;
MPRINT(TMPRED):   set _tmutildoc end=eof;
MPRINT(TMPRED):   * array for holding all probabilities;
MPRINT(TMPRED):   array _p prob1--prob12;
MPRINT(TMPRED):   array _c(12);
MPRINT(TMPRED):   retain _c 0;
MPRINT(TMPRED):   * get rid of working columns;
MPRINT(TMPRED):   drop _max_ _i _WARN_;
MPRINT(TMPRED):   _max_ = 0;
MPRINT(TMPRED):   do _i = 1 to 12;
MPRINT(TMPRED):   if _p(_i) > _max_ then do;
MPRINT(TMPRED):   _max_ = _p(_i);
MPRINT(TMPRED):   _CLUSTER_ = _i;
MPRINT(TMPRED):   end;
MPRINT(TMPRED):   end;
MPRINT(TMPRED):   if (_CLUSTER_ >= 1) and (_CLUSTER_ <= 12) then _c(_CLUSTER_) = _c(_CLUSTER_) + 1;
MPRINT(TMPRED):   else _CLUSTER_ = .;
MPRINT(TMPRED):   ;
MPRINT(TMPRED):   if eof then do;
MPRINT(TMPRED):   output _clusstat;
MPRINT(TMPRED):   output EMWS3.TextCluster_docs;
MPRINT(TMPRED):   end;
MPRINT(TMPRED):   else output EMWS3.TextCluster_docs;
MPRINT(TMPRED):   run;

NOTE: There were 100 observations read from the data set WORK._TMUTILDOC.
NOTE: The data set EMWS3.TEXTCLUSTER_DOCS has 100 observations and 26 variables.
NOTE: Compressing data set EMWS3.TEXTCLUSTER_DOCS increased size by 100.00 percent. 
      Compressed is 2 pages; un-compressed would require 1 pages.
NOTE: The data set WORK._CLUSSTAT has 1 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_CLUSTER):  ;
MPRINT(TM_CLUSTER):   data EMWS3.TextCluster_docs;
MPRINT(TM_CLUSTER):   set EMWS3.TextCluster_docs;
MPRINT(TM_CLUSTER):   rename prob1-prob12 = TextCluster_prob1-TextCluster_prob12;
MPRINT(TM_CLUSTER):   run;

NOTE: There were 100 observations read from the data set EMWS3.TEXTCLUSTER_DOCS.
NOTE: The data set EMWS3.TEXTCLUSTER_DOCS has 100 observations and 26 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_CLUSTER):   data _clusstat;
MPRINT(TM_CLUSTER):   array c(12) _c1-_c12;
MPRINT(TM_CLUSTER):   set _clusstat;
MPRINT(TM_CLUSTER):   totalobs=0;
MPRINT(TM_CLUSTER):   do _CLUSTER_ = 1 to 12;
MPRINT(TM_CLUSTER):   Freq = c(_CLUSTER_);
MPRINT(TM_CLUSTER):   totalobs=totalobs+c(_CLUSTER_);
MPRINT(TM_CLUSTER):   output;
MPRINT(TM_CLUSTER):   end;
MPRINT(TM_CLUSTER):   call symput ('totNumDocs', totalobs);
MPRINT(TM_CLUSTER):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      451:154   
NOTE: There were 1 observations read from the data set WORK._CLUSSTAT.
NOTE: The data set WORK._CLUSSTAT has 12 observations and 15 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_CLUSTER):   data _clusstat;
MPRINT(TM_CLUSTER):   set _clusstat;
MPRINT(TM_CLUSTER):   Percent = Freq/ 100;
MPRINT(TM_CLUSTER):   run;

NOTE: There were 12 observations read from the data set WORK._CLUSSTAT.
NOTE: The data set WORK._CLUSSTAT has 12 observations and 16 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(TM_CLUSTER):   data _clustermean(rename=(TextCluster_SVD1 - TextCluster_SVD12 = _mean1-_mean12));
MPRINT(TM_CLUSTER):   set EMWS3.TextCluster_emoutstat(keep=cluster _TYPE_ TextCluster_SVD1 - TextCluster_SVD12);
MPRINT(TM_CLUSTER):   if _TYPE_ = "MEAN";
MPRINT(TM_CLUSTER):   keep cluster TextCluster_SVD1 - TextCluster_SVD12 ;
MPRINT(TM_CLUSTER):   run;

NOTE: There were 25 observations read from the data set EMWS3.TEXTCLUSTER_EMOUTSTAT.
NOTE: The data set WORK._CLUSTERMEAN has 12 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_CLUSTER):   proc sql;
MPRINT(TM_CLUSTER):   create table _meandocs(drop=cluster) as select a.*, b.* from EMWS3.TextCluster_docs a left join _clustermean b on a._cluster_=b.cluster ;
NOTE: Table WORK._MEANDOCS created, with 100 rows and 38 columns.

MPRINT(TM_CLUSTER):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_CLUSTER):   data _rmscalc;
MPRINT(TM_CLUSTER):   merge _meandocs(in=inhere) _clusstat;
MPRINT(TM_CLUSTER):   array _means(12) _mean1-_mean12;
MPRINT(TM_CLUSTER):   array _svds(12) TextCluster_SVD1 - TextCluster_SVD12;
MPRINT(TM_CLUSTER):   by _cluster_;
MPRINT(TM_CLUSTER):   error=0;
MPRINT(TM_CLUSTER):   do i = 1 to 12;
MPRINT(TM_CLUSTER):   error +( (_svds{i}-_means{i}) * (_svds{i}-_means{i}));
MPRINT(TM_CLUSTER):   end;
MPRINT(TM_CLUSTER):   drop i;
MPRINT(TM_CLUSTER):   run;

NOTE: There were 100 observations read from the data set WORK._MEANDOCS.
NOTE: There were 12 observations read from the data set WORK._CLUSSTAT.
NOTE: The data set WORK._RMSCALC has 100 observations and 54 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_CLUSTER):   proc summary data=_rmscalc nway;
MPRINT(TM_CLUSTER):   class _cluster_;
MPRINT(TM_CLUSTER):   var error;
MPRINT(TM_CLUSTER):   output out=_meanerr mean=meane sum=sume;
MPRINT(TM_CLUSTER):   run;

NOTE: There were 100 observations read from the data set WORK._RMSCALC.
NOTE: The data set WORK._MEANERR has 12 observations and 5 variables.
NOTE: PROCEDURE SUMMARY used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TM_CLUSTER):   data _rmsse;
MPRINT(TM_CLUSTER):   set _meanerr;
MPRINT(TM_CLUSTER):   if _freq_ gt 1 then do;
MPRINT(TM_CLUSTER):   _rmsstd_=sqrt(sume/((_freq_-1)*(12)));
MPRINT(TM_CLUSTER):   end;
MPRINT(TM_CLUSTER):   else do;
MPRINT(TM_CLUSTER):   _rmsstd_=0;
MPRINT(TM_CLUSTER):   end;
MPRINT(TM_CLUSTER):   keep _cluster_ _rmsstd_;
MPRINT(TM_CLUSTER):   run;

NOTE: There were 12 observations read from the data set WORK._MEANERR.
NOTE: The data set WORK._RMSSE has 12 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_CLUSTER):   proc sql;
MPRINT(TM_CLUSTER):   create table _clusstat2(drop=cluster) as select a.*,b.* from _clustermean a left join _rmsse b on a.cluster=b._cluster_;
NOTE: Table WORK._CLUSSTAT2 created, with 12 rows and 14 columns.

MPRINT(TM_CLUSTER):   create table EMWS3.TextCluster_clusters as select a.*, b.freq, b.percent from _clusstat2(keep=_cluster_ _mean1-_mean12 _rmsstd_) a right join _clusstat b on a._cluster_=b._cluster_ where b.freq>0 ;
NOTE: Table EMWS3.TEXTCLUSTER_CLUSTERS created, with 12 rows and 16 columns.

MPRINT(TM_CLUSTER):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.01 seconds
      cpu time            0.03 seconds
      

MPRINT(TM_CLUSTER):   filename temp catalog 'sashelp.emtext.tmterm1.source';
MPRINT(TM_CLUSTER):   proc sort data=EMWS3.TextFilter_terms out=_terms_;
MPRINT(TM_CLUSTER):   by key _ispar;
MPRINT(TM_CLUSTER):   run;

NOTE: Input data set is already sorted; it has been copied to the output data set.
NOTE: There were 204 observations read from the data set EMWS3.TEXTFILTER_TERMS_DATA.
      WHERE KEEP='Y';
NOTE: There were 7276 observations read from the data set EMWS3.TEXTFILTER_TERM_STRINGS.
NOTE: There were 204 observations read from the data set EMWS3.TEXTFILTER_TERMS.
NOTE: The data set WORK._TERMS_ has 204 observations and 13 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TM_CLUSTER):   data _terms_;
MPRINT(TM_CLUSTER):   set _terms_;
MPRINT(TM_CLUSTER):   by key _ispar;
MPRINT(TM_CLUSTER):   if first.key then output;
MPRINT(TM_CLUSTER):   else;
MPRINT(TM_CLUSTER):   run;

NOTE: There were 204 observations read from the data set WORK._TERMS_.
NOTE: The data set WORK._TERMS_ has 170 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_CLUSTER):   data _terms_;
MPRINT(TM_CLUSTER):   set _terms_;
MPRINT(TM_CLUSTER):   if _ispar='+' then Term=_ispar || ' ' || term;
MPRINT(TM_CLUSTER):   run;

NOTE: There were 170 observations read from the data set WORK._TERMS_.
NOTE: The data set WORK._TERMS_ has 170 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TMSORT):   proc sort data = EMWS3.TextFilter_tmout threads out = _tmout_;
MPRINT(TMSORT):   by _termnum_;
MPRINT(TMSORT):   run;

NOTE: There were 504 observations read from the data set EMWS3.TEXTFILTER_TMOUT.
NOTE: The data set WORK._TMOUT_ has 504 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_CLUSTER):  ;
MPRINT(TM_CLUSTER):   data _tmout_;
MPRINT(TM_CLUSTER):   merge _tmout_ (in=_A_) _terms_ (rename=(key=_termnum_ term=_term_) keep=key term );
MPRINT(TM_CLUSTER):   by _termnum_;
MPRINT(TM_CLUSTER):   if _A_;
MPRINT(TM_CLUSTER):   run;

NOTE: There were 504 observations read from the data set WORK._TMOUT_.
NOTE: There were 170 observations read from the data set WORK._TERMS_.
NOTE: The data set WORK._TMOUT_ has 504 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_CLUSTER):   data _docs_;
MPRINT(TM_CLUSTER):   set EMWS3.TextCluster_docs (rename=(index=_document_) keep=index _cluster_);
MPRINT(TM_CLUSTER):   _SEGMNT_=_cluster_;
MPRINT(TM_CLUSTER):  ;
MPRINT(TM_CLUSTER):   run;

NOTE: There were 100 observations read from the data set EMWS3.TEXTCLUSTER_DOCS.
NOTE: The data set WORK._DOCS_ has 100 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create view _CMB as select t1.*, t2._segmnt_ as cluster from _tmout_ t1, _docs_ t2 where t1._document_ = t2._document_ ;
NOTE: SQL view WORK._CMB has been defined.
MPRINT(TMTERM1):   quit ;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TMTERM1):   proc summary data=_CMB nway ;
MPRINT(TMTERM1):   class cluster _term_ ;
MPRINT(TMTERM1):   var _count_ ;
MPRINT(TMTERM1):   output out=_TFREQ sum=total ;
MPRINT(TMTERM1):   run ;

NOTE: There were 504 observations read from the data set WORK._TMOUT_.
NOTE: There were 100 observations read from the data set WORK._DOCS_.
NOTE: There were 504 observations read from the data set WORK._CMB.
NOTE: The data set WORK._TFREQ has 259 observations and 5 variables.
NOTE: PROCEDURE SUMMARY used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(TMTERM1):   proc summary data=_CMB( keep= cluster _document_ ) ;
MPRINT(TMTERM1):   class cluster ;
MPRINT(TMTERM1):   var _document_ ;
MPRINT(TMTERM1):   output out=_SUM n=n ;
MPRINT(TMTERM1):   run ;

NOTE: There were 504 observations read from the data set WORK._TMOUT_.
NOTE: There were 100 observations read from the data set WORK._DOCS_.
NOTE: There were 504 observations read from the data set WORK._CMB.
NOTE: The data set WORK._SUM has 13 observations and 4 variables.
NOTE: PROCEDURE SUMMARY used (Total process time):
      real time           0.00 seconds
      cpu time            0.04 seconds
      

MPRINT(TMTERM1):   data _null_ ;
MPRINT(TMTERM1):   set _SUM ;
MPRINT(TMTERM1):   if _type_ = 1 then call symput( 'CLUSIZE' || left( put( cluster, best. )), put( _freq_, best. ));
MPRINT(TMTERM1):   else if _type_ = 0 then call symput( 'CLUSALL', put( _freq_, best. )) ;
MPRINT(TMTERM1):   run ;

NOTE: There were 13 observations read from the data set WORK._SUM.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _SUM;
NOTE: Table WORK._SUM has been dropped.
MPRINT(TMTERM1):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TMSORT):   proc sort data = _TFREQ THREADS out = _TFREQ;
MPRINT(TMSORT):   by cluster descending _freq_;
MPRINT(TMSORT):   run;

NOTE: There were 259 observations read from the data set WORK._TFREQ.
NOTE: The data set WORK._TFREQ has 259 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _UNQT( keep= _term_ _freq_ cluster ) ;
MPRINT(TMTERM1):   set _TFREQ ;
MPRINT(TMTERM1):   by cluster ;
MPRINT(TMTERM1):   if first.cluster then n_term = 0 ;
MPRINT(TMTERM1):   n_term + 1 ;
MPRINT(TMTERM1):   if n_term le 30 ;
MPRINT(TMTERM1):   run ;

NOTE: There were 259 observations read from the data set WORK._TFREQ.
NOTE: The data set WORK._UNQT has 259 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TMSORT):   proc sort data = _UNQT THREADS nodupkey out = _UNQT( keep= _term_ );
MPRINT(TMSORT):   by _term_;
MPRINT(TMSORT):   run;

NOTE: There were 259 observations read from the data set WORK._UNQT.
NOTE: 193 observations with duplicate key values were deleted.
NOTE: The data set WORK._UNQT has 66 observations and 1 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create table _CLCDF as select distinct cluster, _term_, _freq_ from _TFREQ where _term_ in ( select _term_ from _UNQT ) order by _term_, cluster ;
NOTE: Table WORK._CLCDF created, with 259 rows and 3 columns.

MPRINT(TMTERM1):   quit ;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _UNQT;
NOTE: Table WORK._UNQT has been dropped.
MPRINT(TMTERM1):   drop table _TFREQ;
NOTE: Table WORK._TFREQ has been dropped.
MPRINT(TMTERM1):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(TMTERM1):   proc transpose data=_CLCDF out=_CLCDF prefix=clus ;
MPRINT(TMTERM1):   by _term_ ;
MPRINT(TMTERM1):   var _freq_ ;
MPRINT(TMTERM1):   id cluster;
MPRINT(TMTERM1):   run ;

NOTE: There were 259 observations read from the data set WORK._CLCDF.
NOTE: The data set WORK._CLCDF has 66 observations and 14 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TMTERM1):   data _CLCDF ;
MPRINT(TMTERM1):   length _term_ $100;
MPRINT(TMTERM1):   array a_clus ( 12 ) 4 clus1 - clus12 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   do _i_ = 1 to 12 ;
MPRINT(TMTERM1):   if a_clus( _i_ ) = . then a_clus( _i_ ) = 0 ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   sumfreq = sum( of clus1 - clus12 ) ;
MPRINT(TMTERM1):   if (clus1 = 0) or (clus1 < 0) then cdf1 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus1 ;
MPRINT(TMTERM1):   div = 504 - 29;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf1 = CDF( 'binomial', clus1 , propor , 29 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf1 = 1;
MPRINT(TMTERM1):   else cdf1 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus2 = 0) or (clus2 < 0) then cdf2 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus2 ;
MPRINT(TMTERM1):   div = 504 - 40;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf2 = CDF( 'binomial', clus2 , propor , 40 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf2 = 1;
MPRINT(TMTERM1):   else cdf2 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus3 = 0) or (clus3 < 0) then cdf3 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus3 ;
MPRINT(TMTERM1):   div = 504 - 36;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf3 = CDF( 'binomial', clus3 , propor , 36 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf3 = 1;
MPRINT(TMTERM1):   else cdf3 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus4 = 0) or (clus4 < 0) then cdf4 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus4 ;
MPRINT(TMTERM1):   div = 504 - 46;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf4 = CDF( 'binomial', clus4 , propor , 46 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf4 = 1;
MPRINT(TMTERM1):   else cdf4 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus5 = 0) or (clus5 < 0) then cdf5 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus5 ;
MPRINT(TMTERM1):   div = 504 - 65;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf5 = CDF( 'binomial', clus5 , propor , 65 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf5 = 1;
MPRINT(TMTERM1):   else cdf5 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus6 = 0) or (clus6 < 0) then cdf6 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus6 ;
MPRINT(TMTERM1):   div = 504 - 34;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf6 = CDF( 'binomial', clus6 , propor , 34 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf6 = 1;
MPRINT(TMTERM1):   else cdf6 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus7 = 0) or (clus7 < 0) then cdf7 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus7 ;
MPRINT(TMTERM1):   div = 504 - 19;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf7 = CDF( 'binomial', clus7 , propor , 19 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf7 = 1;
MPRINT(TMTERM1):   else cdf7 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus8 = 0) or (clus8 < 0) then cdf8 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus8 ;
MPRINT(TMTERM1):   div = 504 - 45;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf8 = CDF( 'binomial', clus8 , propor , 45 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf8 = 1;
MPRINT(TMTERM1):   else cdf8 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus9 = 0) or (clus9 < 0) then cdf9 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus9 ;
MPRINT(TMTERM1):   div = 504 - 30;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf9 = CDF( 'binomial', clus9 , propor , 30 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf9 = 1;
MPRINT(TMTERM1):   else cdf9 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus10 = 0) or (clus10 < 0) then cdf10 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus10 ;
MPRINT(TMTERM1):   div = 504 - 51;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf10 = CDF( 'binomial', clus10 , propor , 51 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf10 = 1;
MPRINT(TMTERM1):   else cdf10 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus11 = 0) or (clus11 < 0) then cdf11 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus11 ;
MPRINT(TMTERM1):   div = 504 - 53;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf11 = CDF( 'binomial', clus11 , propor , 53 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf11 = 1;
MPRINT(TMTERM1):   else cdf11 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus12 = 0) or (clus12 < 0) then cdf12 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus12 ;
MPRINT(TMTERM1):   div = 504 - 56;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf12 = CDF( 'binomial', clus12 , propor , 56 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf12 = 1;
MPRINT(TMTERM1):   else cdf12 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   saveplus=0;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),'+')=1 then do;
MPRINT(TMTERM1):   saveplus=1;
MPRINT(TMTERM1):   _term_ = ksubstr(kleft(ktrim(_term_)),3);
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),' ')>0 then _term_ = "'"||kleft(ktrim(_term_)) || "'  ";
MPRINT(TMTERM1):   else _term_ = kleft(ktrim(_term_)) || ' ';
MPRINT(TMTERM1):   if saveplus=1 then do;
MPRINT(TMTERM1):   _term_='+'||kleft(ktrim(_term_));
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   drop _i_ propor sumfreq div num saveplus;
MPRINT(TMTERM1):   run ;

NOTE: There were 66 observations read from the data set WORK._CLCDF.
NOTE: The data set WORK._CLCDF has 66 observations and 26 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(TMTERM1):   data _CLCDFTR ;
MPRINT(TMTERM1):   array a_cdf ( 12 ) cdf1 - cdf12 ;
MPRINT(TMTERM1):   array a_count ( 12 ) clus1 - clus12 ;
MPRINT(TMTERM1):   length clus 4 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   keep _term_ cdf clus doc_count;
MPRINT(TMTERM1):   do clus = 1 to 12 ;
MPRINT(TMTERM1):   cdf = a_cdf( clus ) ;
MPRINT(TMTERM1):   doc_count = a_count( clus ) ;
MPRINT(TMTERM1):   if cdf > 0 then output ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   run ;

NOTE: There were 66 observations read from the data set WORK._CLCDF.
NOTE: The data set WORK._CLCDFTR has 259 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDF;
NOTE: Table WORK._CLCDF has been dropped.
MPRINT(TMTERM1):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TMSORT):   proc sort data = _CLCDFTR THREADS out = _CLCDFTR;
MPRINT(TMSORT):   by clus descending cdf descending doc_count _term_;
MPRINT(TMSORT):   run;

NOTE: There were 259 observations read from the data set WORK._CLCDFTR.
NOTE: The data set WORK._CLCDFTR has 259 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _desc_;
MPRINT(TMTERM1):   set _CLCDFTR (rename=(clus=cluster));
MPRINT(TMTERM1):   format clus_desc $450.;
MPRINT(TMTERM1):   retain oldclus 0 clus_desc '' count 0;
MPRINT(TMTERM1):   keep _CLUSTER_ clus_desc ;
MPRINT(TMTERM1):   if _N_ = 1 then do;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   count = 1;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (count <= 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 1) then clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   else clus_desc = kleft(trim(clus_desc)) || "  " || kleft(trim(_term_));
MPRINT(TMTERM1):   count = count + 1;
MPRINT(TMTERM1):   if (_N_ = 259) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if (count > 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 259) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   count = 2;
MPRINT(TMTERM1):   clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   if (_N_ = 259) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   run;

NOTE: There were 259 observations read from the data set WORK._CLCDFTR.
NOTE: The data set WORK._DESC_ has 12 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDFTR;
NOTE: Table WORK._CLCDFTR has been dropped.
MPRINT(TMTERM1):   drop view _CMB;
NOTE: View WORK._CMB has been dropped.
MPRINT(TMTERM1):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_CLUSTER):  ;
MPRINT(TMSORT):   proc sort data = EMWS3.TextCluster_clusters threads out = EMWS3.TextCluster_clusters;
MPRINT(TMSORT):   by _cluster_;
MPRINT(TMSORT):   run;

NOTE: There were 12 observations read from the data set EMWS3.TEXTCLUSTER_CLUSTERS.
NOTE: The data set EMWS3.TEXTCLUSTER_CLUSTERS has 12 observations and 16 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(TM_CLUSTER):  ;
MPRINT(TMSORT):   proc sort data = _desc_ threads out = _desc_;
MPRINT(TMSORT):   by _cluster_;
MPRINT(TMSORT):   run;

NOTE: There were 12 observations read from the data set WORK._DESC_.
NOTE: The data set WORK._DESC_ has 12 observations and 2 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_CLUSTER):  ;
MPRINT(TM_CLUSTER):   data _desc_;
MPRINT(TM_CLUSTER):   merge EMWS3.TextCluster_clusters _desc_;
MPRINT(TM_CLUSTER):   by _cluster_;
MPRINT(TM_CLUSTER):   run;

NOTE: There were 12 observations read from the data set EMWS3.TEXTCLUSTER_CLUSTERS.
NOTE: There were 12 observations read from the data set WORK._DESC_.
NOTE: The data set WORK._DESC_ has 12 observations and 17 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(TMSORT):   proc sort data = _desc_ threads out = EMWS3.TextCluster_clusters;
MPRINT(TMSORT):   by _cluster_;
MPRINT(TMSORT):   run;

NOTE: There were 12 observations read from the data set WORK._DESC_.
NOTE: The data set EMWS3.TEXTCLUSTER_CLUSTERS has 12 observations and 17 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_CLUSTER):  ;
MPRINT(TM_CLUSTER):   filename temp;
NOTE: Fileref TEMP has been deassigned.
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   * add the info to EMINFO to forward on to other nodes ;
MPRINT(TRAIN):   data EMWS3.TextCluster_EMINFO;
MPRINT(TRAIN):   length TARGET KEY $32 DATA $43;
MPRINT(TRAIN):   key="LastTMNode";
MPRINT(TRAIN):   data="TextCluster";
MPRINT(TRAIN):   output;
MPRINT(TRAIN):   key="LastTMNodeType";
MPRINT(TRAIN):   data="TextCluster";
MPRINT(TRAIN):   output;
MPRINT(TRAIN):   key="LastTextCluster";
MPRINT(TRAIN):   data="TextCluster";
MPRINT(TRAIN):   output;
MPRINT(TRAIN):   key="PRESCORECODE";
MPRINT(TRAIN):   data="TextCluster";
MPRINT(TRAIN):   output;
MPRINT(TRAIN):   run;

NOTE: Variable TARGET is uninitialized.
NOTE: The data set EMWS3.TEXTCLUSTER_EMINFO has 4 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   proc sql noprint;
MPRINT(TRAIN):   select count(*) into :svdkeep from EMWS3.TextCluster_svd_s where keep=1;
MPRINT(TRAIN):   select count(*) into :cluscnt from EMWS3.TextCluster_clusters;
MPRINT(TRAIN):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   data EMWS3.TextCluster_tmconfig;
MPRINT(TRAIN):   set EMWS3.TextCluster_tmconfig;
MPRINT(TRAIN):   clus_alg = "1.0";
MPRINT(TRAIN):   maxsvd = 100;
MPRINT(TRAIN):   svdkeep= 12;
MPRINT(TRAIN):   last_prescore = "TextFilter                                 ";
MPRINT(TRAIN):   run;

NOTE: There were 1 observations read from the data set EMWS3.TEXTCLUSTER_TMCONFIG.
NOTE: The data set EMWS3.TEXTCLUSTER_TMCONFIG has 1 observations and 32 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   length KEY $32 DELETE $1 UNAME $32 ROLE $32 LEVEL $10 ORDER $8 COMMENT $64 LOWERLIMIT 8 UPPERLIMIT 8;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster_CLUSTER_");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("SEGMENT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("NOMINAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   run;

NOTE: The data set WORK.EM_METACHANGE has 1 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster_SVD1");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;

NOTE: There were 1 observations read from the data set WORK.EM_METACHANGE.
NOTE: The data set WORK.EM_METACHANGE has 2 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster_SVD2");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;

NOTE: There were 2 observations read from the data set WORK.EM_METACHANGE.
NOTE: The data set WORK.EM_METACHANGE has 3 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster_SVD3");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;

NOTE: There were 3 observations read from the data set WORK.EM_METACHANGE.
NOTE: The data set WORK.EM_METACHANGE has 4 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster_SVD4");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;

NOTE: There were 4 observations read from the data set WORK.EM_METACHANGE.
NOTE: The data set WORK.EM_METACHANGE has 5 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster_SVD5");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;

NOTE: There were 5 observations read from the data set WORK.EM_METACHANGE.
NOTE: The data set WORK.EM_METACHANGE has 6 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster_SVD6");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;

NOTE: There were 6 observations read from the data set WORK.EM_METACHANGE.
NOTE: The data set WORK.EM_METACHANGE has 7 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster_SVD7");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;

NOTE: There were 7 observations read from the data set WORK.EM_METACHANGE.
NOTE: The data set WORK.EM_METACHANGE has 8 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster_SVD8");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;

NOTE: There were 8 observations read from the data set WORK.EM_METACHANGE.
NOTE: The data set WORK.EM_METACHANGE has 9 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster_SVD9");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;

NOTE: There were 9 observations read from the data set WORK.EM_METACHANGE.
NOTE: The data set WORK.EM_METACHANGE has 10 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster_SVD10");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;

NOTE: There were 10 observations read from the data set WORK.EM_METACHANGE.
NOTE: The data set WORK.EM_METACHANGE has 11 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster_SVD11");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;

NOTE: There were 11 observations read from the data set WORK.EM_METACHANGE.
NOTE: The data set WORK.EM_METACHANGE has 12 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster_SVD12");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;

NOTE: There were 12 observations read from the data set WORK.EM_METACHANGE.
NOTE: The data set WORK.EM_METACHANGE has 13 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster_PROB1");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;

NOTE: There were 13 observations read from the data set WORK.EM_METACHANGE.
NOTE: The data set WORK.EM_METACHANGE has 14 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster_PROB2");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;

NOTE: There were 14 observations read from the data set WORK.EM_METACHANGE.
NOTE: The data set WORK.EM_METACHANGE has 15 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster_PROB3");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;

NOTE: There were 15 observations read from the data set WORK.EM_METACHANGE.
NOTE: The data set WORK.EM_METACHANGE has 16 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster_PROB4");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;

NOTE: There were 16 observations read from the data set WORK.EM_METACHANGE.
NOTE: The data set WORK.EM_METACHANGE has 17 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster_PROB5");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;

NOTE: There were 17 observations read from the data set WORK.EM_METACHANGE.
NOTE: The data set WORK.EM_METACHANGE has 18 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster_PROB6");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;

NOTE: There were 18 observations read from the data set WORK.EM_METACHANGE.
NOTE: The data set WORK.EM_METACHANGE has 19 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster_PROB7");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;

NOTE: There were 19 observations read from the data set WORK.EM_METACHANGE.
NOTE: The data set WORK.EM_METACHANGE has 20 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster_PROB8");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;

NOTE: There were 20 observations read from the data set WORK.EM_METACHANGE.
NOTE: The data set WORK.EM_METACHANGE has 21 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster_PROB9");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;

NOTE: There were 21 observations read from the data set WORK.EM_METACHANGE.
NOTE: The data set WORK.EM_METACHANGE has 22 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster_PROB10");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;

NOTE: There were 22 observations read from the data set WORK.EM_METACHANGE.
NOTE: The data set WORK.EM_METACHANGE has 23 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster_PROB11");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;

NOTE: There were 23 observations read from the data set WORK.EM_METACHANGE.
NOTE: The data set WORK.EM_METACHANGE has 24 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster_PROB12");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;

NOTE: There were 24 observations read from the data set WORK.EM_METACHANGE.
NOTE: The data set WORK.EM_METACHANGE has 25 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   filename temp;
WARNING: No logical assign for filename TEMP.
MPRINT(MAIN):  ;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End TRAIN: TextCluster;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
34931      *------------------------------------------------------------*;
34932      * End TRAIN: TextCluster;
34933      *------------------------------------------------------------*;

34934      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
34935      * Close any missing semi colons;
MPRINT(EM_DIAGRAM):   * Close any missing semi colons;
34936      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
34937      ;
MPRINT(EM_DIAGRAM):   ;
34938      ;
MPRINT(EM_DIAGRAM):   ;
34939      ;
MPRINT(EM_DIAGRAM):   ;
34940      ;
MPRINT(EM_DIAGRAM):   ;
34941      quit;
MPRINT(EM_DIAGRAM):   quit;
34942      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
34943      * Close any unbalanced quotes;
MPRINT(EM_DIAGRAM):   * Close any unbalanced quotes;
34944      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
34945      /*; *"; *'; */
34946      ;
MPRINT(EM_DIAGRAM):   ;
34947      run;
MPRINT(EM_DIAGRAM):   run;
34948      quit;
MPRINT(EM_DIAGRAM):   quit;
34949      /* Reset EM Options */
34950      options formchar="|----|+|---+=|-/\<>*";
MPRINT(EM_DIAGRAM):   options formchar="|----|+|---+=|-/\<>*";
34951      options nocenter ls=256 ps=10000;
MPRINT(EM_DIAGRAM):   options nocenter ls=256 ps=10000;
34952      goptions reset=all device=GIF NODISPLAY;
MPRINT(EM_DIAGRAM):   goptions reset=all device=GIF NODISPLAY;
34953      proc sort data=WORK.EM_METACHANGE;
MPRINT(EM_DIAGRAM):    proc sort data=WORK.EM_METACHANGE;
34954      by key uname;
MPRINT(EM_DIAGRAM):   by key uname;
34955      run;
MPRINT(EM_DIAGRAM):   run;

NOTE: There were 25 observations read from the data set WORK.EM_METACHANGE.
NOTE: The data set WORK.EM_METACHANGE has 25 observations and 9 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

34956      filename x "D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextCluster\CDELTA_TRAIN.sas";
MPRINT(EM_DIAGRAM):    filename x "D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextCluster\CDELTA_TRAIN.sas";
34957      data _null_;
MPRINT(EM_DIAGRAM):   data _null_;
34958      file x;
MPRINT(EM_DIAGRAM):   file x;
34959      put 'if upcase(NAME) = "TEXTCLUSTER_CLUSTER_" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER_CLUSTER_" then do;';
34960      put 'ROLE = "SEGMENT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "SEGMENT";';
34961      put 'LEVEL = "NOMINAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "NOMINAL";';
34962      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
34963      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
34964      put 'if upcase(NAME) = "TEXTCLUSTER_PROB1" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER_PROB1" then do;';
34965      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
34966      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
34967      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
34968      put 'if upcase(NAME) = "TEXTCLUSTER_PROB10" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER_PROB10" then do;';
34969      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
34970      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
34971      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
34972      put 'if upcase(NAME) = "TEXTCLUSTER_PROB11" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER_PROB11" then do;';
34973      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
34974      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
34975      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
34976      put 'if upcase(NAME) = "TEXTCLUSTER_PROB12" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER_PROB12" then do;';
34977      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
34978      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
34979      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
34980      put 'if upcase(NAME) = "TEXTCLUSTER_PROB2" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER_PROB2" then do;';
34981      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
34982      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
34983      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
34984      put 'if upcase(NAME) = "TEXTCLUSTER_PROB3" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER_PROB3" then do;';
34985      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
34986      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
34987      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
34988      put 'if upcase(NAME) = "TEXTCLUSTER_PROB4" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER_PROB4" then do;';
34989      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
34990      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
34991      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
34992      put 'if upcase(NAME) = "TEXTCLUSTER_PROB5" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER_PROB5" then do;';
34993      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
34994      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
34995      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
34996      put 'if upcase(NAME) = "TEXTCLUSTER_PROB6" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER_PROB6" then do;';
34997      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
34998      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
34999      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
35000      put 'if upcase(NAME) = "TEXTCLUSTER_PROB7" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER_PROB7" then do;';
35001      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
35002      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
35003      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
35004      put 'if upcase(NAME) = "TEXTCLUSTER_PROB8" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER_PROB8" then do;';
35005      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
35006      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
35007      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
35008      put 'if upcase(NAME) = "TEXTCLUSTER_PROB9" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER_PROB9" then do;';
35009      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
35010      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
35011      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
35012      put 'if upcase(NAME) = "TEXTCLUSTER_SVD1" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER_SVD1" then do;';
35013      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
35014      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
35015      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
35016      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
35017      put 'if upcase(NAME) = "TEXTCLUSTER_SVD10" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER_SVD10" then do;';
35018      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
35019      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
35020      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
35021      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
35022      put 'if upcase(NAME) = "TEXTCLUSTER_SVD11" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER_SVD11" then do;';
35023      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
35024      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
35025      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
35026      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
35027      put 'if upcase(NAME) = "TEXTCLUSTER_SVD12" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER_SVD12" then do;';
35028      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
35029      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
35030      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
35031      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
35032      put 'if upcase(NAME) = "TEXTCLUSTER_SVD2" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER_SVD2" then do;';
35033      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
35034      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
35035      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
35036      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
35037      put 'if upcase(NAME) = "TEXTCLUSTER_SVD3" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER_SVD3" then do;';
35038      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
35039      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
35040      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
35041      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
35042      put 'if upcase(NAME) = "TEXTCLUSTER_SVD4" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER_SVD4" then do;';
35043      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
35044      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
35045      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
35046      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
35047      put 'if upcase(NAME) = "TEXTCLUSTER_SVD5" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER_SVD5" then do;';
35048      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
35049      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
35050      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
35051      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
35052      put 'if upcase(NAME) = "TEXTCLUSTER_SVD6" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER_SVD6" then do;';
35053      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
35054      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
35055      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
35056      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
35057      put 'if upcase(NAME) = "TEXTCLUSTER_SVD7" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER_SVD7" then do;';
35058      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
35059      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
35060      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
35061      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
35062      put 'if upcase(NAME) = "TEXTCLUSTER_SVD8" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER_SVD8" then do;';
35063      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
35064      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
35065      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
35066      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
35067      put 'if upcase(NAME) = "TEXTCLUSTER_SVD9" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER_SVD9" then do;';
35068      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
35069      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
35070      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
35071      run;
MPRINT(EM_DIAGRAM):   run;

NOTE: The file X is:
      Filename=D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextCluster\CDELTA_TRAIN.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=0,
      Last Modified=16Jan2022:18:08:04,
      Create Time=01Jan2022:15:49:06

NOTE: 112 records were written to the file X.
      The minimum record length was 4.
      The maximum record length was 49.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

35072      filename x;
MPRINT(EM_DIAGRAM):   filename x;
NOTE: Fileref X has been deassigned.
MPRINT(EM_DIAGRAM):    proc printto;
MPRINT(EM_DIAGRAM):   run;
