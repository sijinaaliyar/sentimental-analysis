MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "January 16, 2022" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "17:40:28" );
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Training Log";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
*------------------------------------------------------------*
* Training Log
Date:                January 16, 2022
Time:                17:40:28
*------------------------------------------------------------*
MPRINT(EM_DIAGRAM):    filename O27H44TW "D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextParsing\EMTRAIN.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   proc printto print=O27H44TW new;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOG "D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextParsing\EMLOG.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "January 16, 2022" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "17:40:28" );
MPRINT(EM_DIAGRAM):   file _LOG;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "User:                hp";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "Site:                70166022";
MPRINT(EM_DIAGRAM):   put "Platform:            W32_10HOME";
MPRINT(EM_DIAGRAM):   put "Maintenance Release: 9.04.01M5P091317";
MPRINT(EM_DIAGRAM):   put "EM Version:          14.3";
MPRINT(EM_DIAGRAM):   put "* ";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOGIN "D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextParsing\EMTRAIN.log" encoding="UTF-8" NOBOM;
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file _LOG MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("_LOGIN",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _LOGIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _LOG mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   filename _LOGIN "D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextParsing\EMSCORE.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   file _LOG mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOGIN "D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextParsing\EMREPORT.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _LOGIN;
MPRINT(EM_DIAGRAM):    filename _LOG;
MPRINT(EM_DIAGRAM):    filename _OUT "D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextParsing\EMOUTPUT.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "January 16, 2022" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "17:40:28" );
MPRINT(EM_DIAGRAM):   file _OUT;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "User:                hp";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Training Output";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextParsing\EMTRAIN.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   ;
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file _OUT MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("_OUTIN",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _OUT mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   put // "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Score Output";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextParsing\EMSCORE.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _OUT mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   put // "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Report Output";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextParsing\EMREPORT.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    filename _OUT;
MPRINT(EM_DIAGRAM):    filename _emtool_ 'D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextParsing\EMRUNSTATUS.xml' encoding="UTF-8" NOBOM;
22653      proc freq data=EMWS3.TextParsing_VariableSet noprint;
MPRINT(EM_DIAGRAM):    proc freq data=EMWS3.TextParsing_VariableSet noprint;
22654      table ROLE*LEVEL/out=WORK.TextParsingMETA;
MPRINT(EM_DIAGRAM):   table ROLE*LEVEL/out=WORK.TextParsingMETA;
22655      run;
MPRINT(EM_DIAGRAM):   run;

NOTE: There were 1 observations read from the data set EMWS3.TEXTPARSING_VARIABLESET.
NOTE: The data set WORK.TEXTPARSINGMETA has 1 observations and 4 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

22656      proc print data=WORK.TextParsingMETA label noobs;
MPRINT(EM_DIAGRAM):   proc print data=WORK.TextParsingMETA label noobs;
22657      var ROLE LEVEL COUNT;
MPRINT(EM_DIAGRAM):   var ROLE LEVEL COUNT;
22658      label ROLE = "%sysfunc(sasmsg(sashelp.dmine, meta_role_vlabel, NOQUOTE))" LEVEL = "%sysfunc(sasmsg(sashelp.dmine, meta_level_vlabel, NOQUOTE))" COUNT = "%sysfunc(sasmsg(sashelp.dmine, rpt_count_vlabel, NOQUOTE))";
MPRINT(EM_DIAGRAM):   label ROLE = "Role" LEVEL = "Measurement Level" COUNT = "Frequency Count";
22659      title9 ' ';
MPRINT(EM_DIAGRAM):   title9 ' ';
22660      title10 "%sysfunc(sasmsg(sashelp.dmine, rpt_varSummary_title  , NOQUOTE))";
MPRINT(EM_DIAGRAM):   title10 "Variable Summary";
MPRINT(EM_DIAGRAM):   run;
22661      run;

NOTE: There were 1 observations read from the data set WORK.TEXTPARSINGMETA.
NOTE: The PROCEDURE PRINT printed page 1.
NOTE: PROCEDURE PRINT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

22662      title10;
MPRINT(EM_DIAGRAM):   title10;
22663      %let EMEXCEPTIONSTRING=;
MPRINT(EM_DIAGRAM):     *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * TextParsing: Generation of macros and macro variables;
MPRINT(EM_DIAGRAM):   * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * TextParsing: EM Macro Variables and Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   * System Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   length string $2000;
MPRINT(EM_DIAGRAM):   string = 'Sentimental_Analysis_SAS';
MPRINT(EM_DIAGRAM):   call symput('EM_PROJECTNAME', trim(string));
MPRINT(EM_DIAGRAM):   string = 'Resaturant_Review';
MPRINT(EM_DIAGRAM):   call symput('EM_WSNAME', trim(string));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   * Properties Macro Variables ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Files Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Import Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Export Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Decision Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Statement Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * General Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Target Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Input Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Rejected Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Misc Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End Create EM Macro Variables and Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
22996      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
22997      * TextParsing: Generation of macros and macro variables;
MPRINT(EM_DIAGRAM):   * TextParsing: Generation of macros and macro variables;
22998      * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
MPRINT(EM_DIAGRAM):   * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
22999      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;

23000      %let EMEXCEPTIONSTRING=;
23001      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
23002      * TRAIN: TextParsing;
MPRINT(EM_DIAGRAM):   * TRAIN: TextParsing;
23003      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
23004      %let EM_ACTION = TRAIN;
23005      %let syscc = 0;
23006      %macro main();
23007        %if %upcase(&EM_ACTION) eq CREATE %then %do;
23008          filename temp catalog 'sashelp.emtxtext.parse_create.source';
23009          %include temp;
23010          %create();
23011        %end;
23012        %if %upcase(&EM_ACTION) eq TRAIN %then %do;
23013          filename temp catalog 'sashelp.emtxtext.parse_train.source';
23014          %include temp;
23015          %train();
23016        %end;
23017        %if %upcase(&EM_ACTION) eq REPORT %then %do;
23018          filename temp catalog 'sashelp.emtxtext.parse_report.source';
23019          %include temp;
23020          %report();
23021        %end;
23022        %if %upcase(&EM_ACTION) eq SCORE %then %do;
23023          filename temp catalog 'sashelp.emtxtext.parse_score.source';
23024          %include temp;
23025          %score();
23026        %end;
23027          %if %upcase(&EM_ACTION) eq OPENTABLE1 %then %do;
23028             filename temp catalog 'sashelp.emtxtext.parse_actions.source';
23029             %include temp;
23030             filename temp;
23031             %openTable1;
23032         %end;
23033      %mend main;
23034      
23035      %main();
MPRINT(EM_DIAGRAM):    
MPRINT(MAIN):   filename temp catalog 'sashelp.emtxtext.parse_train.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTXTEXT.PARSE_TRAIN.SOURCE.
23036     +%macro train();
23037     +   %global EM_SASMSG;
23038     +   %global sysdocparse;
23039     +   %global syshptmine;
23040     +   %global default_entity;
23041     +   %let EM_SASMSG=TMINE;
23042     +   %let sysdocparse = ;
23043     +   %let syshptmine = ;
23044     +   %let last_parse_node= ;
23046     +   /* Make sure there are no prior text parsing nodes in diagram */
23047     +   %if %sysfunc(exist(&EM_IMPORT_DATA_EMINFO)) %then %do;
23048     +      proc sql noprint;
23049     +      select data into :last_parse_node from &EM_IMPORT_DATA_EMINFO
23050     +         where key="LastTextParsing";
23051     +      quit;
23052     +      %if &last_parse_node ne %then %do;
23053     +         %let EMEXCEPTIONSTRING = EMTOOL.PRIORPARSINGNODE;
23054     +         %goto end_parse_train;
23055     +         %end;
23057     +      %end;
23060     +   /* make sure datasets are inited*/
23061     +    filename temp catalog 'sashelp.emtxtext.parse_actions.source';
23062     +    %include temp;
23063     +    %openTable1();
23065     +   /* check language setinit at runtime */
23066     +   filename temp catalog "sashelp.emtxtext.getlanguages.source";
23067     +   %include temp;
23068     +   %let found_language = ;
23069     +   proc sql noprint;
23070     +      select language into :found_language
23071     +      from work.tm_languages
23072     +      where upcase("&EM_PROPERTY_LANGUAGE") eq upcase(language);
23073     +   quit;
23074     +   %if &found_language eq %then %do;
23075     +      * error if language setinit expired ;
23076     +      /* %let EMEXCEPTIONSTRING = EMTOOL.NOTMLICENSE; */
23077     +      %let EMEXCEPTIONSTRING = EMTOOL.NOLANGLICENSE, %upcase(&EM_PROPERTY_LANGUAGE);
23078     +      %goto end_parse_train;
23079     +   %end;
23081     +   /* There must be a training or raw data set passed in */
23082     +    %if &em_import_data= %then %do;
23083     +      %let EMEXCEPTIONSTRING = EMTOOL.NOTRAINDS;
23084     +      %goto end_parse_train;
23085     +   %end;
23088     +   /* load tgparse macro */
23089     +   filename temp catalog "sashelp.emtxtext.tm_parse.source";
23090     +   %include temp;
23092     +   /* load multiword write to xml macro */
23093     +   filename temp catalog "sashelp.emtxtext.tmwritemulti.source";
23094     +   %include temp;
23096     +   /* retrieve the output datasets so we can write to them */
23097     +   %em_getname(key=terms, type=data);
23098     +   %em_getname(key=tmout, type=data);
23099     +   %em_getname(key=tmoutpos, type=data);
23100     +   %em_getname(key=tmconfig, type=data);
23101     +   %em_getname(key=synonymDS, type=data);
23102     +   %em_getname(key=multiDS, type=data);
23103     +   %em_getname(key=stopList, type=data);
23104     +   %em_getname(key=startList, type=data);
23106     +   %em_getname(key=multiword, type=file, extension=txt);
23108     +   /* variables for choosing the parsing column */
23109     +   %let tm_parsevar = ;
23110     +   %let tm_urivar = ;
23111     +   %let tm_filteredvar = ;
23112     +   %let tm_displayVar = ;
23114     +   /* crawl through the metadata to set some property defaults */
23115     +   data _null_;
23116     +      length parsevar urivar filteredvar $32;
23117     +      retain max_len 0;
23118     +      retain parsevar '';
23119     +      retain urivar '';
23120     +      retain filteredvar '';
23122     +      set &em_data_variableset end=eof;
23124     +      if upcase(ROLE)='TEXT' and USE in ('Y', 'D') and length > max_len then do;
23125     +         parsevar = name;
23126     +         max_len = length;
23127     +      end;
23128     +      if upcase(ROLE)='TEXTLOC' and USE in ('D', 'Y') then filteredvar = name;
23129     +      if ROLE='URIVAR' and USE in ('D', 'Y') then urivar = name;
23131     +      if eof then do;
23132     +         call symput('tm_parsevar', parsevar);
23133     +         call symput('tm_urivar', urivar);
23134     +         call symput('tm_filteredvar', filteredvar);
23135     +      end;
23136     +   run;
23139     +   %if %trim(%left(&tm_filteredvar)) ne %then %do;
23140     +      %let tm_displayVar = &tm_parseVar;
23141     +      %let tm_parsevar = &tm_filteredvar;
23142     +   %end;
23144     +   %em_propertychange(NAME=parseVar, VALUE=&tm_parsevar);
23146     +   %if %trim(%left(&tm_parsevar)) eq %then %do;
23147     +      /* error if no parsevar is found */
23148     +      %let EMEXCEPTIONSTRING = EMTOOL.NOPARSEVAR;
23149     +      %goto end_parse_train;
23150     +   %end;
23151     +   %else %do;
23152     +      /* identify which variable we are parsing */
23153     +      %put &em_codebar;
23154     +      %let errormsg = %sysfunc(sasmsg(sashelp.tmine, EMTOOL.PARSEVAR_NOTE, NOQUOTE, &tm_parsevar));
23155     +      %put &errormsg;
23156     +      %put &em_codebar;
23157     +   %end;
23159     +   /* *** synonym data set changes *** */
23160     +   /* modify the synonymDS to a format that docparse can take (term, termrole, parent, parentrole) */
23161     +   %let category_exists = 0;
23162     +   %let termrole_exists = 0;
23163     +   %let parentrole_exists = 0;
23164     +   %let synonym_warning = ;
23165     +   data _null_;
23166     +      dsid=open("&EM_USER_SYNONYMDS");
23167     +      check=varnum(dsid,'category');
23168     +      if check ne 0 then call symput('category_exists', '1');
23169     +      check=varnum(dsid,'termrole');
23170     +      if check ne 0 then call symput('termrole_exists', '1');
23171     +      check=varnum(dsid,'parentrole');
23172     +      if check ne 0 then call symput('parentrole_exists', '1');
23173     +   run;
23175     +   proc sql noprint;
23176     +      create table work.internal_synds as
23177     +         select term, parent,
23178     +            %if &termrole_exists ne 0 and &parentrole_exists ne 0 %then %do;
23179     +            /* termrole exists and parentrole exists, so just use them */
23180     +               termrole, parentrole
23181     +            %end;
23182     +            %else %if &termrole_exists ne 0 and &parentrole_exists eq 0 %then %do;
23183     +            /* no parentrole or category, so create a termrole as parentrole */
23184     +               %let synonym_warning = 1 ;
23185     +               termrole,
23186     +               termrole as parentrole
23187     +            %end;
23188     +            %else %if &termrole_exists eq 0 and &parentrole_exists ne 0 %then %do;
23189     +            /* no termrole or category, so create a parentrole as termrole*/
23190     +               %let synonym_warning = 1 ;
23191     +               parentrole as termrole,
23192     +               parentrole
23193     +            %end;
23194     +            %else %if &termrole_exists eq 0 and &parentrole_exists eq 0 and &category_exists eq 0 %then %do;
23195     +             /* no termrole, parentrole, and category, so create a blank termrole and a blank parentrole*/
23196     +               "" as termrole,
23197     +               "" as parentrole
23198     +            %end;
23199     +            %else %if &category_exists ne 0 %then %do;
23200     +            /* we're missing both termrole or parentrole, but we have category, so just use that for termrole and parentrole */
23201     +               category as termrole,
23202     +               category as parentrole
23203     +            %end;
23204     +         from &EM_USER_SYNONYMDS;
23205     +   quit;
23207     +   /* reset parentrole_exists and termrole_exists */
23208     +   %let parentrole_exists = 1;
23209     +   %let termrole_exists = 1;
23212     +    %let entities='PERSON', 'DATE', 'COMPANY', 'PERCENT', 'PROP_MISC', 'TITLE',
23213     +                 'TIME', 'PHONE', 'INTERNET', 'ORGANIZATION', 'CURRENCY', 'ADDRESS',
23214     +                 'NOUN_GROUP', 'MEASURE', 'LOCATION', 'SSN', 'TIME_PERIOD';
23216     +    data work.internal_synds;
23217     +        set work.internal_synds;
23218     +        %if &termrole_exists %then %do;
23219     +            if KUPCASE(termrole) in (&entities ) then
23220     +                termrole=KUPCASE(termrole);
23221     +        %end;
23222     +        %if &parentrole_exists %then %do;
23223     +            if KUPCASE(parentrole) in (&entities) then
23224     +                parentrole=KUPCASE(parentrole);
23225     +        %end;
23226     +    run;
23228     +   %let EM_USER_SYNONYMDS = work.internal_synds;
23229     +   %if &synonym_warning ne %then %do;
23230     +      %put &em_codebar;
23231     +      %let errormsg = %sysfunc(sasmsg(sashelp.tmine, EMTOOL.SYN_CHANGE_WARN, NOQUOTE));
23232     +      %put &errormsg;
23233     +      %put &em_codebar;
23234     +   %end;
23236     +   /* Remove duplicate keys from input tables */
23237     +    proc sort data=work.internal_synds nodupkey;
23238     +        by term parent %if &termrole_exists ne 0 and &parentrole_exists ne 0 %then termrole parentrole;
23239     +        %else category; ;
23240     +    run;
23242     +   proc sql noprint;
23243     +       select count(*) into :stoplist_count
23244     +       from &em_user_stoplist;
23245     +       select count(*) into :startlist_count
23246     +       from &em_user_startlist;
23247     +       create view _trainview as select * from &em_import_data;
23248     +    quit;
23250     +    %if &stoplist_count ne 0 %then %do;
23251     +        %let role_exists = 0;
23252     +        data _null_;
23253     +          dsid=open("&em_user_stoplist");
23254     +          check=varnum(dsid,'role');
23255     +          if check ne 0 then call symput('role_exists', '1');
23256     +        run;
23257     +        proc sort data=&em_user_stoplist nodupkey;
23258     +            by term %if &role_exists ne 0 %then role;;
23259     +        run;
23260     +    %end;
23261     +    %else %if &startlist_count ne 0 %then %do;
23262     +        proc sort data=&em_user_startlist nodupkey;
23263     +            by term role;
23264     +        run;
23265     +    %end;
23269     +    /* Filter out unwanted languages */
23270     +    %let filt=;
23271     +    %if %symexist(EM_PROPERTY_FILTERLANG) %then %if &EM_PROPERTY_FILTERLANG ne %then %do;
23272     +        %let filt=%qkupcase(&EM_PROPERTY_FILTERLANG);
23273     +        %let filt=%qsysfunc(KTRANSLATE(%qktrim(&filt),", "," "));
23274     +        %let filt= %superq(filt);
23275     +        %let filt=%qsysfunc(TRANSTRN(&filt, %str(%')%qkupcase(%sysfunc(sasmsg(sashelp.tmine, rpt_text_blank_value, NOQUOTE)))%str(%'), ''));
23276     +        /* need to account for both Chinese languages */
23277     +        %let chineseStr = %qkupcase(%ktrim(%sysfunc(sasmsg(sashelp.tmine, rpt_text_chinese_value, NOQUOTE)))', '%ktrim(%sysfunc(sasmsg(sashelp.tmine, rpt_text_zho_value, NOQUOTE)))', '%ktrim(%sysfunc(sasmsg(sashelp.tmine, rpt_text_zht_value,
23278     + NOQUOTE))));
23279     +        %let filt=%qsysfunc(TRANSTRN(&filt, %qkupcase(%ktrim(%sysfunc(sasmsg(sashelp.tmine, rpt_text_chinese_value, NOQUOTE)))), &chineseStr));
23281     +        filename temp catalog 'sashelp.emtxtext.tm_filter_languages.source';
23282     +        %include temp;
23284     +        %tm_filter_languages(indata=&EM_IMPORT_DATA, outdata=_trainview, languages=%nrbquote(&filt), report_role=TRAIN);
23286     +        proc sql noprint;
23287     +            select count(*) into :doccnt from _trainview;
23288     +        quit;
23290     +        %if &doccnt = 0 %then %do;
23291     +            %let emexceptionstring=EMTOOL.FILTER_DATA_ZERO;
23292     +            %goto end_parse_train;
23293     +        %end;
23294     +    %end;
23296     +    /* prepare training dataset for processing */
23297     +    data &EM_EXPORT_TRAIN.(compress=yes);
23298     +        set _trainview;
23300     +        _document_ = _n_;
23301     +        label _document_="%sysfunc(sasmsg(sashelp.tmine, rpt_text_document_vlabel, NOQUOTE))";
23302     +    run;
23304     +   /* set metadata on &EM_EXPORT_TRAIN to give _document_ a role of id and
23305     +      measurement level of nominal
23306     +    */
23307     +   %em_metachange(name=_document_, role=ID, level=NOMINAL);
23309     +   /* Write the multiword XML out */
23310     +   %tmwritemulti(multids=&EM_USER_MULTIDS,
23311     +                 stopds=&EM_USER_STOPLIST,
23312     +                 startds=&EM_USER_STARTLIST,
23313     +                 synds=&EM_USER_SYNONYMDS,
23314     +                 multi=&EM_USER_MULTIWORD,
23315     +                 multidsout= &EM_LIB..&EM_NODEID._multiall);
23316     +%let default_entity=;
23317     +   /* The main parsing call for the docs */
23318     +   %tm_parse(inds=&EM_EXPORT_TRAIN,
23319     +             outds=&em_user_tmout,
23320     +             keyds=&EM_USER_TERMS,
23321     +             config=&EM_USER_TMCONFIG,
23322     +             multisyn=&EM_USER_MULTIWORD,
23323     +             var=&TM_PARSEVAR,
23324     +             stemming=&EM_PROPERTY_BSTEMS,
23325     +             filevar=&tm_filteredvar,
23326     +             stoplist=&EM_USER_stopList,
23327     +             startlist=&EM_USER_startList,
23328     +             delimit=&EM_PROPERTY_DELIMIT,
23329     +             tagging=&EM_PROPERTY_BPARTOFSPEECH,
23330     +             language=&EM_PROPERTY_LANGUAGE,
23331     +             ng=&EM_PROPERTY_NOUNGROUPS,
23332     +             TGConcepts=%superq(EM_PROPERTY_TGConcepts),
23333     +             TGCategories=&EM_PROPERTY_TGCategories,
23334     +             indexDir=&EM_NODEDIR.&EM_DSEP.,
23335     +             entities=&EM_PROPERTY_BPATTERNS,
23336     +             posignore=&EM_PROPERTY_IGNOREPOS,
23337     +             entignore=&EM_PROPERTY_IGNOREENTITIES,
23338     +             attribignore=&EM_PROPERTY_IGNOREATTRIB,
23339     +             filterds=,
23340     +             filterstatus=,
23341     +             synDS=&EM_USER_SYNONYMDS,
23342     +             outpos=&EM_USER_TMOUTPOS);
23345     +   %if %superq(syshptmine) ne  %then %do;
23346     +      %let EMEXCEPTIONSTRING = EMTOOL.HPTMINE,%superq(syshptmine);
23347     +      %let syscc=0;
23348     +      %goto end_parse_train;
23349     +   %end;
23351     +   %else  %if %superq(sysdocparse) ne  %then %do;
23352     +      %let EMEXCEPTIONSTRING = EMTOOL.DOCPARSE,%superq(sysdocparse);
23353     +      %let syscc=0;
23354     +      %goto end_parse_train;
23355     +   %end;
23358     +    /* add rolestring and attrstring labels for  roles and strings to data set*/
23359     +    proc sql;
23362     +       create table &EM_USER_TERMS as
23363     +         select
23364     +            a.key label= "%sysfunc(sasmsg(sashelp.tmine,rpt_text_key_vlabel,NOQUOTE))",
23365     +            a.term label= "%sysfunc(sasmsg(sashelp.tmine,rpt_text_term_vlabel,NOQUOTE))",
23366     +            a.role,
23367     +            case a.role
23368     +               when 'Abbr'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posabbr_value,   NOQUOTE))"
23369     +               when 'Adj'           then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posadj_value,   NOQUOTE))"
23370     +               when 'Adv'           then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posadv_value,   NOQUOTE))"
23371     +               when 'Aux'           then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posaux_value,   NOQUOTE))"
23372     +               when 'Conj'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posconj_value,   NOQUOTE))"
23373     +               when 'Det'           then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posdet_value,   NOQUOTE))"
23374     +               when 'Interj'        then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posinterj_value,   NOQUOTE))"
23375     +               when 'Noun'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posnoun_value,   NOQUOTE))"
23376     +               when 'Num'           then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posnum_value,   NOQUOTE))"
23377     +               when 'Part'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_pospart_value,   NOQUOTE))"
23378     +               when 'Pref'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_pospref_value,   NOQUOTE))"
23379     +               when 'Prep'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posprep_value,   NOQUOTE))"
23380     +               when 'Pron'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_pospron_value,   NOQUOTE))"
23381     +               when 'Prop'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posprop_value,   NOQUOTE))"
23382     +               when 'Punct'         then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_pospunct_value,   NOQUOTE))"
23383     +               when 'Verb'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posverb_value,   NOQUOTE))"
23384     +               when 'VerbAdj'       then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posverbadj_value,   NOQUOTE))"
23385     +               when 'PERSON'        then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posperson_value,   NOQUOTE))"
23386     +               when 'ORGANIZATION'  then  "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posorganizationerson_value, NOQUOTE))"
23387     +               when 'LOCATION'      then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_poslocation_value, NOQUOTE))"
23388     +               when 'COMPANY'       then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_poscompany_value,  NOQUOTE))"
23389     +               when 'TITLE'         then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_postitle_value,    NOQUOTE))"
23390     +               when 'PHONE'         then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posphone_value,    NOQUOTE))"
23391     +               when 'DATE'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posdate_value,     NOQUOTE))"
23392     +               when 'TIME'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_postime_value,     NOQUOTE))"
23393     +               when 'INTERNET'      then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posinternet_value, NOQUOTE))"
23394     +               when 'MEASURE'       then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posmeasure_value,  NOQUOTE))"
23395     +               when 'NOUN_GROUP'    then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posnoungroup_value,  NOQUOTE))"
23396     +               when 'SSN'           then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posssn_value,        NOQUOTE))"
23397     +               when 'CURRENCY'      then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_poscurrency_value,   NOQUOTE))"
23398     +               when 'PERCENT'       then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_pospercent_value,    NOQUOTE))"
23399     +               when 'TIME_PERIOD'   then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_postimeperiod_value, NOQUOTE))"
23400     +               when 'PROP_MISC'     then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_pospropmisc_value,   NOQUOTE))"
23401     +               when 'VEHICLE'       then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posvehicle_value,    NOQUOTE))"
23402     +               when 'ADDRESS'       then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posaddress_value,    NOQUOTE))"
23403     +               else              a.role
23404     +          end as rolestring label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_role_vlabel,NOQUOTE))",
23405     +          a.attribute,
23406     +          case a.attribute
23407     +              when 'Alpha'         then  "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_attralpha_value,   NOQUOTE))"
23408     +              when 'Mixed'         then  "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_attrmixed_value,   NOQUOTE))"
23409     +              when 'Num'           then    "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_attrnum_value,   NOQUOTE))"
23410     +              when 'Entity'        then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_attrentity_value,   NOQUOTE))"
23411     +               else             a.ATTRIBUTE
23412     +          end as attrstring label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_attribute_vlabel,NOQUOTE))",
23413     +          /*No weight var at this point*/
23414     +           /*a.weight label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_weight_vlabel,NOQUOTE))" format=5.3,*/
23415     +           a.freq label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_freq_vlabel,NOQUOTE))",
23416     +           a.numdocs label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_numdocs_vlabel,NOQUOTE))",
23417     +           a.keep label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_keep_vlabel,NOQUOTE))",
23418     +           a._ispar label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_isparent_vlabel,NOQUOTE))",
23419     +           a.parent label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_parent_vlabel,NOQUOTE))",
23420     +           a.parent_id label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_parentid_vlabel,NOQUOTE))"
23421     +         from &EM_USER_TERMS  a;
23422     +    quit;
23423     +   data &EM_USER_tmconfig;
23424     +      length multiencoding $24 NG $3
23425     +         %if %superq(EM_PROPERTY_TGConcepts) ne %then %do;
23426     +         litilist $%eval(%klength(%superq(EM_PROPERTY_TGConcepts)) + 2 +
23427     +                       %klength(%superq(default_entity)))
23428     +            %end;
23429     +            ;
23430     +      set &EM_USER_tmconfig;
23432     +            parseVar = lowcase("&tm_parseVar");
23433     +            displayVar = lowcase("&tm_displayVar");
23434     +            indexpath = "&EM_NODEDIR.&EM_DSEP.";
23435     +            multiencoding="utf-8";
23436     +            %if %nrbquote(&filt) ne %then filterLangs="%nrbquote(&filt)"; %else filterLangs="";;
23438     +            /* Need to correct differences between hptmine and tgparse values for tmconfig
23439     +               table [cox] 11/24/2014  These may need to be changed again if we use
23440     +               proc hptmscore for scoring. */
23442     +            if NG="Y" then NG="STD"; else if NG="N" then NG="OFF";
23443     +            if entities="STD" then entities="Y";
23444     +            language=lowcase(language);
23445     +            %if %superq(EM_PROPERTY_TGConcepts) ne
23446     +               and ((&EM_PROPERTY_BPATTERNS eq CUSTOM and %upcase(&EM_PROPERTY_NOUNGROUPS) eq Y)
23447     +                    or &EM_PROPERTY_BPATTERNS eq ALL) %then %do;
23448     +                    litilist="%superq(EM_PROPERTY_TGConcepts)"||';'|| "%superq(default_entity)";
23449     +                    %end;
23450     +            %else %if &EM_PROPERTY_BPATTERNS eq CUSTOM %then %do;
23451     +               entities="Y";
23452     +               litilist="%superq(EM_PROPERTY_TGConcepts)";
23453     +               %end;
23455     +            run;
23458     +   /* Sort our terms data set and create an index for it
23459     +      Sort by term */
23460     +   proc sort data=&em_user_terms;
23461     +      %if %sysfunc(strip(&EM_PROPERTY_IGNOREPOS)) ne %then %do;
23462     +         by term role;
23463     +      %end;
23464     +      %else %do;
23465     +         by term;
23466     +      %end;
23467     +   run;
23469     +   /* Save the dataset information out to EMINFO */
23470     +   data &EM_DATA_EMINFO;
23471     +      length TARGET KEY $32 DATA $43;
23473     +      key="LastTMNode";
23474     +      data="&EM_NODEID";
23475     +      output;
23477     +      key="LastTMNodeType";
23478     +      data="TextParsing";
23479     +      output;
23481     +      key="LastTextParsing";
23482     +      data="&EM_NODEID";
23483     +      output;
23484     +    %if &filt ne %then %do;
23485     +          key="PRESCORECODE";
23486     +          data="&EM_NODEID";
23487     +          output;
23488     +    %end;
23489     +   run;
23493     +%end_parse_train:
23494     +   filename temp;
23495     +   %if ^%symexist(tm_debug) %then %let tm_debug=0;
23496     +   %if &tm_debug =0 %then %do;
23497     +      proc sql noprint;
23498     +         drop table internal_synds;
23499     +         drop table tm_languages;
23500     +         drop view _trainview;
23501     +      quit;
23502     +   %end;
23505     +%mend train;
NOTE: %INCLUDE (level 1) ending.
MPRINT(TRAIN):   filename temp catalog 'sashelp.emtxtext.parse_actions.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTXTEXT.PARSE_ACTIONS.SOURCE.
23506     +%macro openTable1();
23507     +/* initiate all possible tables if not already there*/
23509     +   %em_getname(key=synonymDS, type=data);
23510     +   %em_getname(key=multiDS, type=data);
23511     +   %em_getname(key=stopList, type=data);
23512     +   %em_getname(key=startList, type=data);
23514     +   /* set a macro for conditional Syn actions */
23515     +   %global tm_parse_action_syn;
23516     +   %let tm_parse_action_syn=1;
23518     +   %if ^%sysfunc(exist(&em_user_stoplist)) %then %do;
23519     +      proc sql noprint;
23520     +         create table &em_user_stopList
23521     +         (term char(256)
23522     +label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_stop_term_vlabel, NOQUOTE))",
23523     +          role char(256)
23524     +label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_stop_role_vlabel, NOQUOTE))"
23525     +             );
23526     +      quit;
23527     +      data &em_user_stoplist;
23528     +         format term $256.;
23529     +         set &em_user_stoplist &em_property_stoplist;
23530     +      run;
23531     +   %end;
23533     +   %if ^%sysfunc(exist(&em_user_synonymds)) %then %do;
23534     +      proc sql noprint;
23535     +         create table &em_user_synonymDS
23536     +         (term char(256)
23537     +label="%sysfunc(sasmsg(sashelp.tmine,  rpt_text_syn_term_vlabel, NOQUOTE))",
23538     +          termrole char(256)
23539     +label="%sysfunc(sasmsg(sashelp.tmine,  rpt_text_syn_termrole_vlabel, NOQUOTE))",
23540     +          parent char(256)
23541     +label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_syn_parent_vlabel, NOQUOTE))",
23542     +          parentrole char(256)
23543     +label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_syn_parentrole_vlabel, NOQUOTE))"
23544     +             );
23545     +      quit;
23546     +      data &em_user_synonymds;
23547     +         set &em_user_synonymDS &em_property_synonymds;
23548     +      run;
23549     +   %end;
23551     +   %if ^%sysfunc(exist(&em_user_multids)) %then %do;
23552     +      proc sql noprint;
23553     +         create table &em_user_multiDS
23554     +         (term char(256)
23555     +label="%sysfunc(sasmsg(sashelp.tmine, RPT_TEXT_STOP_TERM_VLABEL, NOQUOTE))",
23556     +          role char(256)
23557     +label="%sysfunc(sasmsg(sashelp.tmine, RPT_TEXT_STOP_ROLE_VLABEL, NOQUOTE))"
23558     +             );
23559     +       quit;
23561     +      data &em_user_multids;
23562     +         set &em_user_multids &em_property_multids;
23563     +      run;
23564     +   %end;
23566     +   %if ^%sysfunc(exist(&em_user_startList)) %then %do;
23567     +     proc sql noprint;
23568     +      create table &EM_USER_startList
23569     +         (term char(256)
23570     +label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_stop_term_vlabel, NOQUOTE))",
23571     +          role char(256)
23572     +label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_stop_role_vlabel, NOQUOTE))"
23573     +             );
23574     +    quit;
23575     +    data &em_user_startlist;
23576     +         set &em_user_startlist &em_property_startlist;
23577     +      run;
23579     +   %end;
23581     +%mend openTable1;
NOTE: %INCLUDE (level 1) ending.
MPRINT(OPENTABLE1):  ;
MPRINT(OPENTABLE1):  ;
MPRINT(OPENTABLE1):  ;
MPRINT(OPENTABLE1):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   filename temp catalog "sashelp.emtxtext.getlanguages.source";
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTXTEXT.GETLANGUAGES.SOURCE.
23583     +data work.raw_tm_languages work.all_languages;
MPRINT(TRAIN):   data work.raw_tm_languages work.all_languages;
23584     +   length language $20;
MPRINT(TRAIN):   length language $20;
23585     +   input language $1-14 displaytext $15-69 prodnum;
MPRINT(TRAIN):   input language $1-14 displaytext $15-69 prodnum;
23586     +
23587     +   output work.all_languages;
MPRINT(TRAIN):   output work.all_languages;
23588     +   if prodnum = 0 or sysprod("PRODNUM"||left(trim(put(prodnum, 8.))))
23589     +        then output work.raw_tm_languages;
MPRINT(TRAIN):   if prodnum = 0 or sysprod("PRODNUM"||left(trim(put(prodnum, 8.)))) then output work.raw_tm_languages;
23590     +   drop prodnum;
MPRINT(TRAIN):   drop prodnum;
23591     +
23592     +   datalines;
MPRINT(TRAIN):   datalines;

NOTE: The data set WORK.RAW_TM_LANGUAGES has 1 observations and 2 variables.
NOTE: The data set WORK.ALL_LANGUAGES has 28 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   ;
MPRINT(TRAIN):   run;
23621     +;
23622     +run;
23623     +
23624     +
23625     +
23626     +
23627     +proc sql noprint;
MPRINT(TRAIN):   proc sql noprint;
23628     +   create table work.tm_languages as
23629     +      select distinct(language), displaytext
23630     +      from work.raw_tm_languages;
MPRINT(TRAIN):   create table work.tm_languages as select distinct(language), displaytext from work.raw_tm_languages;
NOTE: Table WORK.TM_LANGUAGES created, with 1 rows and 2 columns.

23631     +   create table work.all_tm_languages as
23632     +      select distinct(language), displaytext
23633     +      from work.all_languages;
MPRINT(TRAIN):   create table work.all_tm_languages as select distinct(language), displaytext from work.all_languages;
NOTE: Table WORK.ALL_TM_LANGUAGES created, with 27 rows and 2 columns.

23634     +   drop table work.raw_tm_languages;
MPRINT(TRAIN):   drop table work.raw_tm_languages;
NOTE: Table WORK.RAW_TM_LANGUAGES has been dropped.
23635     +   drop table work.all_languages;
MPRINT(TRAIN):   drop table work.all_languages;
NOTE: Table WORK.ALL_LANGUAGES has been dropped.
23636     +quit;
MPRINT(TRAIN):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

23637     +
NOTE: %INCLUDE (level 1) ending.
MPRINT(TRAIN):   proc sql noprint;
MPRINT(TRAIN):   select language into :found_language from work.tm_languages where upcase("ENGLISH") eq upcase(language);
MPRINT(TRAIN):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   filename temp catalog "sashelp.emtxtext.tm_parse.source";
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTXTEXT.TM_PARSE.SOURCE.
23638     +/* ****************************************************************
23639     + * Name:    tmparse (macro)
23640     + *
23641     + * Support: Jim Cox
23642     + *
23643     + * Usage: %tm_parse(inds=,outds=,keyds=,synds=sashelp.engsynms,keyvar=_document_,
23644     + *                var=,docidvar=, filevar=,config=,
23645     + *                stemming=Y,tagging=Y,ng=Y,entities=NONE,
23646     + *                stoplist=, startlist=, inkey=,doc_id=,
23647     + *                posignore=, entignore=,entkeep=, attribignore=,
23648     + *                reducef=1,termwgt=,cellwgt=,
23649     + *                language=english, multisyn=, nopos=, TGConcepts=,
23650     + *                TGCategories=, indexDir=,out_parent=,
23651     + *                delimit=Formal,outpos=,filterds=,filterstatus=drop);
23652     + * Purpose: To run Text parsing
23653     + *
23654     + * Parms:
23655     + * inds=<dataset> Specifies the input document dataset. This ds has a variable containing
23656     + *      the actual text or a path to the actual text.
23657     + * outds=<dataset> The output OUT table containing variables _TERMNUM_,
23658     + *      _DOCUMENT_,ENTRY. This represents the output term-by- document
23659     + *      frequency matrix.
23660     + * keyds=<dataset> Species the output terms table of terms with their
23661     + *      assoiciated KEY(numeric id) and summary statistics
23662     + * synds=<dataset> An input data set for applying user defined synonyms.
23663     + *      The dataset should contain variables TERM and PARENT and
23664     + *      optionally TERMROLE and PARENTROLE. All occurrences in the text of
23665     + *      matching strings for the term will be assigned the associated parent.
23666     + * keyvar=_document_
23667     + * var=<variable name> Specifies the variable on the inds dataset
23668     + *      that contains the text to be parsed.
23669     + * docidvar=<variable name> This specifies an integer valued variable
23670     + *      that must be on the inds document table. Rather than indexing documents
23671     + *      from 1 to n, this optional setting allow you to control what
23672     + *      id values for documents are used on the OUTds table
23673     + * filevar= Instead of var=, this speicifies the variable on the inds dataset
23674     + *      that contains a path to the plain text documents to be parsed.
23675     + * config=<dataset> An output and an input dataset containing the settings specfied
23676     + *      on this run. If the config exists when specified, the settings
23677     + *      found in the config file will override settings on this macro.
23678     + * stemming=<Y or N> Determines if terms will be stemmed to their root forms.
23679     + * tagging=<Y or N> Determines if the parsed terms will be assigned a
23680     + *      part-of-speech tag.
23681     + * ng=<Y or N> Determines if noun groups will be found as terms.
23682     + * entities=<NONE,DEFAULT, CUSTOM, ALL> Controls if entities are
23683     + *      found during the parse
23684     + *      NONE - do not find entities
23685     + *      DEFAULT - Identify the standard entities
23686     + *      CUSTOM - Use a customizeed file to extract user-specific
23687     + *               entities
23688     + *      ALL - identify the standard entities and extract user-specific entities.
23689     + * stoplist= <dataset> Provide an input list of terms to stop. Variables
23690     + *       are TERM and optionally TERMROLE
23691     + * startlist=<dataset> Provide an input list of terms to keep (all others
23692     + *       will be stopped). Variables are TERM and optionally TERMROLE
23693     + * inkey= <dataset> This option is there to support iterative parsing
23694     + *      It controls the numbering of terms.  The data set inkey comes
23695     + *      from a previous parse and proc tgparse uses the term keys found
23696     + *      there so that identical terms will receive the same key as a previous
23697     + *      parse.
23698     + * doc_id=<nonneg integer>  This also supports iterative parsing and tells
23699     + *      tgparse to start numbering docs at Doc_id rather than with a 1.
23700     + * posignore="POS1" "POS2" .... Allows user to specify a list of part-of-
23701     + *      speech tags. Any terms with these tags will be removed.
23702     + *      For example  posignore="DET" "PREP"
23703     + * entignore="ENT1" "ENT2"... Allows user to specify a list of entity
23704     + *      types. Any terms with these tags will be removed.
23705     + *      For example  entignore="COMPANY" "PRODUCT"
23706     + * entkeep="ENT1" "ENT2" ... Allows user to specify a list of entity
23707     + *      types. Any terms with these tags will be kept and all others
23708     + *       remove. *      For example  entkeep="COMPANY" "PRODUCT"
23709     + * attribignore="ATTRIB1" "ATTRIB2"...Allows user to specify a list of
23710     + *      attributes. Any terms with these attribues will be removed.
23711     + *      For example  posignore="NUM" "PUNCT"
23712     + * reducef=<Positive Integer> Setting lets you specify when to dynamically
23713     + *      stop terms from the analysis. They must appear in at least
23714     + *      reducef documents in order to be kept.
23715     + * termwgt=<NONE, ENTROPY, oR MI> Specify the term weight for each term
23716     + * cellwgt=<NONE or LOG> Specify the cell weight for terms
23717     + * language=<english> Specify the langugage of the text you are parsing
23718     + * multisyn=<filename> Specify the path to a custom multiword term file.
23719     + * nopos=
23720     + * TGConcepts=<filename> Specify the location of custom concept definition
23721     + *       file
23722     + * TGCategories= IGNORED CURRENTLY
23723     + * indexDir= The output location of the search index that can be built with the
23724     + *    input document data.
23725     + * out_parent= An output term-document table that has all children's
23726     + *    (from stemming and synonyms )frequencies
23727     + *    replaced and attributed to their parents. This is the representative form
23728     + *    for the parse collection
23729     + * delimit=Formal IGNORED CURRENTLY
23730     + * outpos=<dataset> An output dataset containing the offset information of
23731     + *    every term in the collection.
23732     + * filterds=<dataset> The name of the dataset of terms used for filtering.
23733     + *        This data set can be used to set terms to keep or drop based
23734     + *        on the filterstatus setting.
23735     + * filterstatus=drop
23736     + * langchk=yes
23737     + *
23738     + * Returns:
23739     + *
23740     + * History:
23741     + * 01Dec05 Initial Coding [cox]
23742     + *
23743     + *
23744     + * Notes:
23745     + * Last Modified By:
23746     + * Last Modified On: Wed Jul 12 14:19:58 2017
23747     + * End
23748     + * ************************************************************** */
23749     +
23750     +%macro tm_parse(inds=,outds=,keyds=,synds=sashelp.engsynms,docidvar=_document_,
23751     +                 var=, filevar=, config=,
23752     +                 stemming=Y,tagging=Y,ng=Y,entities=NONE,
23753     +                 stoplist=, startlist=, inkey=,doc_id=,reducef=1,termwgt=,cellwgt=,
23754     +                 posignore=, entignore=,entkeep=, attribignore=,
23755     +                 language=english, multisyn=, nopos=, TGConcepts=,
23756     +                 TGCategories=, indexDir=,out_parent=, langchk=yes,
23757     +                 delimit=Formal,outpos=,filterds=,filterstatus=drop);
23758     +
23759     +%global default_entity;
23760     +%let language=%lowcase(&language);
23761     +%let attribtest=%upcase(&attribignore);
23762     +%let filterstatus=%upcase(&filterstatus);
23763     +%if ^%symexist(tm_hptmineBuildIndex) %then %let tm_hptmineBuildIndex=1;
23764     +%if ^%symexist(tm_hptmineBuildIndex) %then %let tm_hptmineBuildIndex=1;
23765     +%if &tm_hptmineBuildIndex ne 1 %then %let tm_hptmineBuildIndex=0;
23766     +
23767     +
23768     +/* Now do tests to determine which proc we will run */
23769     +%if &tm_hptmineBuildIndex=0 and %nrbquote(&indexDir) ne %then %let parse_proc=tgparse;
23770     +
23771     +/* if asked to select/drop entities or pos also use tgparse
23772     +    [cox] No longer true so removing condition 9/4/2014 */
23773     +/* %else %if &posignore ne or &entignore ne or &entkeep ne
23774     +    %then %let parse_proc=tgparse;
23775     +*/
23776     +
23777     +/* otherwise, if language not English or German, use tgparse */
23778     +/* [cox] Condition removed 07/12/2017 since all languages will use hptmine in 9.4m5 */
23779     +/*
23780     +%else %if &language ne english and &language ne german and
23781     +   &language ne chinese and &language ne spanish and
23782     +   &language ne italian and &language ne portuguese and
23783     +   &language ne dutch and &language ne korean and
23784     +   &language ne french and &language ne russian and
23785     +   &language ne finnish and &language ne turkish
23786     +   and &language ne japanese  and &langchk = yes
23787     + %then %let parse_proc=tgparse;
23788     +*/
23789     +
23790     +/* Otherwise, attribignore must contain NUM and PUNCT but not ABBR, ALPHA, or MIXED
23791     +  [cox] No longer true so removing condition 9/4/2014
23792     +  */
23793     +/*
23794     +%else %if %index(&attribtest, NUM) eq 0 or %index(&attribtest, PUNCT) eq 0 or
23795     +   %index(&attribtest, ABBR) ne 0 or %index(&attribtest, ALPHA) ne 0 or
23796     +   %index(&attribtest, MIXED) ne 0 %then %let parse_proc=tgparse;
23797     +*/
23798     +
23799     +/* finally, must not be updating a previously generated key table */
23800     +
23801     +%else %if &inkey ne %then %let parse_proc=tgparse;
23802     +   %else %let parse_proc=hptmine;
23803     +
23804     +   /* delete the tmconfig file so we do not use another tmconfig from a previous node */
23805     +   %if &config ne %then %do;
23806     +      proc sql noprint;
23807     +         drop table &config;
23808     +      quit;
23809     +   %end;
23810     +
23811     +
23812     +   /* fix quote problems (replace single quote with double quotes) in posignore=,
23813     +      entignore=, attribignore= .  What about entkeep= (cox)? */
23814     +   data _null_;
23815     +      %if %ktrim(&posignore) ne %then %do;
23816     +         posignore = "&posignore";
23817     +         posignore = transtrn(posignore, "'", '"');
23818     +         call symput("posignore", posignore);
23819     +      %end;
23820     +      %if %ktrim(&entignore) ne %then %do;
23821     +         entignore = "&entignore";
23822     +         entignore = transtrn(entignore, "'", '"');
23823     +         call symput("entignore", entignore);
23824     +      %end;
23825     +      %if %ktrim(&attribignore) ne %then %do;
23826     +         attribignore = "&attribignore";
23827     +         attribignore = transtrn(attribignore, "'", '"');
23828     +         call symput("attribignore", attribignore);
23829     +      %end;
23830     +   run;
23831     +
23832     +   %let stoplist_count = 0;
23833     +   %let startlist_count = 0;
23834     +   %let synds_count = 0;
23835     +   proc sql noprint;
23836     +      %if "&stoplist" ne "" %then %do;
23837     +         select count(*) into :stoplist_count
23838     +         from &stoplist;
23839     +      %end;
23840     +      %if "&startlist" ne "" %then %do;
23841     +         select count(*) into :startlist_count
23842     +         from &startlist;
23843     +      %end;
23844     +      %if "&synds" ne "" %then %do;
23845     +         select count(*) into :synds_count
23846     +         from &synds;
23847     +      %end;
23848     +   quit;
23849     +
23850     +   /* control behavior of custom entities */
23851     +   %if &parse_proc eq tgparse %then %let ent_true=yes; %else %let ent_true=std;
23852     +   %if &parse_proc eq tgparse %then %let ent_false=no; %else %let ent_false=none;
23853     +   %let entity_info = ;
23854     +   %if &entities eq NONE %then %do;
23855     +      %let entity_info = entities=&ent_false ;
23856     +      %let entignore = ; %let entkeep=;
23857     +   %end;
23858     +   %else %if &entities eq DEFAULT %then %do;
23859     +      %let entity_info = entities=&ent_true ;
23860     +   %end;
23861     +   /* Otherwise entities are CUSTOM or ALL */
23862     +   %else %do;
23863     +      /* Need to set up default entities if NG on or entities set to ALL */
23864     +      %if &entities eq ALL or %upcase(&ng) eq Y %then %do;
23865     +      %let default_entity = %sysfunc(pathname(SASROOT))&EM_DSEP ;
23866     +
23867     +      %if "&EM_DSEP" eq "/" %then %do;
23868     +         /* unix */
23869     +         %let default_entity = &default_entity.misc&EM_DSEP.tktg&EM_DSEP. ;
23870     +         %end;
23871     +      %else %if "&EM_DSEP" eq "\" %then %do;
23872     +         /* windows */
23873     +         %let default_entity = &default_entity.tktg&EM_DSEP.sasmisc&EM_DSEP. ;
23874     +         %end;
23875     +      %let entity_language = %lowcase(&language);
23876     +
23877     +      %if "&entity_language" eq "arabic" %then %do;
23878     +         %let default_entity = &default_entity.ar-ne.li ;
23879     +         %end;
23880     +      %else %if "&entity_language" eq "german" %then %do;
23881     +         %let default_entity = &default_entity.de-ne.li ;
23882     +         %end;
23883     +      %else %if "&entity_language" eq "english" %then %do;
23884     +         %let default_entity = &default_entity.en-ne.li ;
23885     +         %end;
23886     +      %else %if "&entity_language" eq "spanish" %then %do;
23887     +         %let default_entity = &default_entity.es-ne.li ;
23888     +         %end;
23889     +      %else %if "&entity_language" eq "french" %then %do;
23890     +         %let default_entity = &default_entity.fr-ne.li ;
23891     +         %end;
23892     +      %else %if "&entity_language" eq "italian" %then %do;
23893     +         %let default_entity = &default_entity.it-ne.li ;
23894     +         %end;
23895     +      %else %if "&entity_language" eq "japanese" %then %do;
23896     +         %let default_entity = &default_entity.jp-ne.li ;
23897     +         %end;
23898     +      %else %if "&entity_language" eq "korean" %then %do;
23899     +         %let default_entity = &default_entity.kr-ne.li ;
23900     +         %end;
23901     +      %else %if "&entity_language" eq "dutch" %then %do;
23902     +         %let default_entity = &default_entity.nl-ne.li ;
23903     +         %end;
23904     +      %else %if "&entity_language" eq "polish" %then %do;
23905     +         %let default_entity = &default_entity.pl-ne.li ;
23906     +         %end;
23907     +      %else %if "&entity_language" eq "portuguese" %then %do;
23908     +         %let default_entity = &default_entity.pt-ne.li ;
23909     +         %end;
23910     +      %else %if "&entity_language" eq "chinese" %then %do;
23911     +         %let default_entity = &default_entity.zh-ne.li ;
23912     +         %end;
23913     +      %else %if "&entity_language" eq "russian" %then %do;
23914     +         %let default_entity = &default_entity.ru-ne.li ;
23915     +         %end;
23916     +      %else %if "&entity_language" eq "turkish" %then %do;
23917     +         %let default_entity = &default_entity.tr-ne.li ;
23918     +         %end;
23919     +      %else %if "&entity_language" eq "thai" %then %do;
23920     +         %let default_entity = &default_entity.th-ne.li ;
23921     +         %end;
23922     +      %else %if "&entity_language" eq "vietnamese" %then %do;
23923     +         %let default_entity = &default_entity.vi-ne.li ;
23924     +         %end;
23925     +      %else %if "&entity_language" eq "norwegian" %then %do;
23926     +         %let default_entity = &default_entity.no-ne.li ;
23927     +         %end;
23928     +      %else %if "&entity_language" eq "danish" %then %do;
23929     +         %let default_entity = &default_entity.da-ne.li ;
23930     +         %end;
23931     +      %else %if "&entity_language" eq "greek" %then %do;
23932     +         %let default_entity = &default_entity.el-ne.li ;
23933     +         %end;
23934     +      %else %if "&entity_language" eq "romanian" %then %do;
23935     +         %let default_entity = &default_entity.ro-ne.li ;
23936     +         %end;
23937     +      %else %if "&entity_language" eq "hebrew" %then %do;
23938     +         %let default_entity = &default_entity.he-ne.li ;
23939     +         %end;
23940     +      %else %if "&entity_language" eq "czech" %then %do;
23941     +         %let default_entity = &default_entity.cs-ne.li ;
23942     +         %end;
23943     +      %else %if "&entity_language" eq "slovak" %then %do;
23944     +         %let default_entity = &default_entity.sk-ne.li ;
23945     +         %end;
23946     +      %else %if "&entity_language" eq "hungarian" %then %do;
23947     +         %let default_entity = &default_entity.hu-ne.li ;
23948     +         %end;
23949     +      %else %if "&entity_language" eq "indonesian" %then %do;
23950     +         %let default_entity = &default_entity.id-ne.li ;
23951     +         %end;
23952     +      %else %if "&entity_language" eq "finnish" %then %do;
23953     +         %let default_entity = &default_entity.fi-ne.li ;
23954     +         %end;
23955     +      %else %let default_entity=&ent_false;
23956     +
23957     +         %end;
23958     +
23959     +   %if &entities eq CUSTOM %then %do;
23960     +      %if %superq(TGConcepts) ne %then %do;
23961     +         %if &parse_proc eq tgparse %then %let ent_flag=&ent_true;
23962     +         %else %let ent_flag=&ent_false;
23963     +         %let entity_info = entities=&ent_flag litilist=("&TGConcepts") ;
23964     +      %end;
23965     +      %else %do;
23966     +         %let entity_info = entities=&ent_false ;
23967     +      %end;
23968     +
23969     +      /* %let entignore = ; */
23970     +      %end;
23971     +   %else %if &entities eq ALL %then %do;
23972     +
23973     +      %if %nrbquote(&TGConcepts) ne %then %do;
23974     +         %if &parse_proc eq tgparse %then
23975     +            %let entity_info= entities=&ent_true litilist=("&default_entity" "&TGConcepts") ;
23976     +         %else %let entity_info= entities=&ent_true litilist=("&TGConcepts") ;
23977     +         %end;
23978     +      %else %let entity_info= entities=&ent_true;
23979     +
23980     +
23981     +      %end;
23982     +
23983     +%end;
23984     +
23985     +   /* main docparse call */
23986     +%if &parse_proc eq tgparse %then %do;
23987     +      proc tgparse data=&inds key=&keyds out=&outds
23988     +         %if &filterds ne %then %do;
23989     +            %if %upcase(&filterstatus) eq DROP %then stop=&filterds;
23990     +            %else %if %upcase(&filterstatus) eq KEEP %then start=&filterds;
23991     +            %else %if %upcase(&filterstatus) eq IGNORE %then ignore=&filterds;
23992     +            %else %if %upcase(&filterstatus) eq RETAIN %then retain=&filterds;
23993     +            %end;
23994     +         %if &config ne %then config=&config;
23995     +         %if &nopos ne %then NOPOS;
23996     +         %if &synds_count ne 0 %then syn=&synds;
23997     +         %if "&multisyn" ne "" %then multiterm="&multisyn";
23998     +         %if %upcase(&stemming) eq Y %then stemming=yes ; %else stemming=no ;
23999     +         %if %upcase(&tagging) eq Y %then tagging=yes ; %else tagging=no ;
24000     +         &entity_info
24001     +         /* %if "%trim(%left(&TGCategories))" ne "" %then TGCategories=&TGCategories ; */
24002     +         %if "%nrbquote(&indexDir)" ne "" %then %do;
24003     +            buildindex=yes
24004     +            indexpath="%nrbquote(&indexDir)"
24005     +         %end;
24006     +         %if &stoplist_count ne 0  %then stop=&stoplist;
24007     +         %else %if &startlist_count ne 0  %then start=&startlist;
24008     +         %if %upcase(&ng) eq Y %then ng=std ;
24009     +         %else ng=off ;
24010     +         %if &filevar ne %then namedfile;
24011     +         %if %lowcase(&language) ne other %then language=%lowcase(&language);
24012     +         %else plugin="SAS";
24013     +         %if &outpos ne %then %do; outoffset=&outpos addsentence addparagraph %end;
24014     +         %if &inkey ne %then  inkey=&inkey;
24015     +         %if &doc_id ne %then doc_id=&doc_id;
24016     +
24017     +         ;
24018     +      var %if &filevar ne %then &filevar; %else &var; ;
24019     +      %if %upcase(&docidvar) ne _DOCUMENT_ %then id &docidvar;;
24020     +
24021     +      select &posignore "Newline" / drop;
24022     +      %if &attribignore ne %then select &attribignore / group="attributes" drop; ;
24023     +      %if &entkeep ne and &entignore =  %then %do;
24024     +          select &entkeep / group="entities" keep;
24025     +      %end;
24026     +      %else %do;
24027     +          %if &entignore ne %then select &entignore / group="entities" drop; ;
24028     +      %end;
24029     +      run;
24030     +%end;
24031     +
24032     +%else %do;
24033     +
24034     +proc hptmine data=&inds language=&language;
24035     +    var %if &filevar ne %then &filevar; %else &var; ;
24036     +   doc_id &docidvar;
24037     +   parse reducef=&reducef outterms=&keyds
24038     +      %if &filevar ne %then namedfile;
24039     +
24040     +      %if &filterds ne %then %do;
24041     +          %if %upcase(&filterstatus) eq DROP or %upcase(&filterstatus) eq IGNORE
24042     +             %then stop=&filterds;
24043     +          %else %if %upcase(&filterstatus) eq KEEP or %upcase(&filterstatus) eq RETAIN
24044     +             %then start=&filterds;
24045     +          %if %upcase(&filterstatus) ne IGNORE and %upcase(&filterstatus) ne RETAIN
24046     +             %then showdroppedterms;
24047     +      %end;
24048     +      %else showdroppedterms;
24049     +
24050     +      %if &termwgt ne %then termwgt=&termwgt;
24051     +      %if &cellwgt ne %then cellwgt=&cellwgt;
24052     +      %if %upcase(&stemming) ne Y %then nostemming;
24053     +      %if %upcase(&tagging) ne Y %then notagging;
24054     +      %if %upcase(&ng) ne Y %then nonoungroups;
24055     +   %if &stoplist_count ne 0  %then stop=&stoplist;
24056     +   %else %if &startlist_count ne 0  %then start=&startlist;
24057     +%if 0 %then %do;
24058     +%end;
24059     +      %if &synds_count ne 0 %then syn=&synds;
24060     +         &entity_info
24061     +      %if "&multisyn" ne "" %then multiterm="&multisyn";
24062     +      %if "%nrbquote(&indexDir)" ne "" %then %do;
24063     +            buildindex
24064     +            indexpath="%nrbquote(&indexDir)"
24065     +      %end;
24066     +
24067     +      %if &outds ne %then outchild=&outds;
24068     +      %if &outpos ne %then outpos=&outpos;
24069     +      %if &config ne %then outconfig=&config;
24070     +      %if &out_parent ne %then outparent=&out_parent;
24071     +
24072     +   ;
24073     +     %if &posignore ne %then select &posignore / ignore; ;
24074     +        %if &attribignore eq %then %let attribignore="";
24075     +      select &attribignore / group="attributes" ignore;
24076     +      %if &entkeep ne and &entignore =  %then %do;
24077     +         select &entkeep / group="entities" keep; ;
24078     +      %end;
24079     +      %else %do;
24080     +          %if &entignore ne %then select &entignore / group="entities" ignore; ;
24081     +      %end;
24082     +      performance /* nthreads=1 */ details;
24083     +   run;
24084     +%if %symexist(syshptmine) %then %let sysdocparse=&syshptmine;
24085     +%else %let sysdocparse=;
24086     +
24087     +/* Change term and outpos tables so that they correspond to tgparse variable names */
24088     +proc sql noprint;
24089     +   create table &keyds as select *,_keep as keep from &keyds
24090     +      order by _keep desc,numdocs desc;
24091     +  %if &outpos ne %then %do;
24092     +     create table &outpos as select
24093     +        a.document as _document_,
24094     +        a.sentence as _sentence_,
24095     +        a._start_ as _offset_,
24096     +        a._end_ -a._start_+1 as _length_,
24097     +        b.key as _termnum_,
24098     +        c._count_
24099     +        from &outpos as a, &keyds as b, &outds as c
24100     +        where b._ispar ne '+' and b.term=a.term and b.role=a.role and b.key=c._termnum_ and
24101     +        a.document=c._document_;
24102     +        %end;
24103     +      quit;
24104     +
24105     +%end;
24106     +
24107     +%end_tmparse:
24108     +
24109     +%mend;
NOTE: %INCLUDE (level 1) ending.
MPRINT(TRAIN):   filename temp catalog "sashelp.emtxtext.tmwritemulti.source";
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTXTEXT.TMWRITEMULTI.SOURCE.
24110     +/* ****************************************************************
24111     + * Name:    tmwritemulti.sas (macro)
24112     + *
24113     + *
24114     + * Usage: %tmwritemulti(multids=, stopds=, startds=, synds=, multi=);
24115     + * Purpose: To write out the text file for the multiword dictionary.  This will
24116     + *  include multiword term in the data= file as well as
24117     + * Parameters
24118     + * multids   = data set with multiword terms and their roles
24119     + * stopds    = stop word list - look for multiword terms
24120     + * startds   = start word list - look for multiword terms
24121     + * synds     = data set with synonyms and their roles
24122     + * multi     = multiterm text file.
24123     + * End
24124     + * ************************************************************** */
24125     +
24126     +
24127     +%macro tmwritemulti(multids=, stopds=, startds=, synds=, multi=, multidsout=);
24128     +
24129     +   * create a multiword terms data set ;
24130     +   proc sql noprint;
24131     +      create table _multiterms_
24132     +         (term   char(256),
24133     +          role   char(256));
24134     +   quit;
24135     +
24136     +   %let synds_count = ;
24137     +   %let stopds_count = ;
24138     +   %let startds_count = ;
24139     +   %let multids_count = ;
24140     +   proc sql noprint;
24141     +      select count(*) into :synds_count
24142     +      from &synds;
24143     +
24144     +      select count(*) into :stopds_count
24145     +      from &stopds;
24146     +
24147     +      %if &startds ne %then
24148     +      select count(*) into :startds_count
24149     +      from &startds;
24150     +      %else %let startds_count = 0;;
24151     +
24152     +      select count(*) into :multids_count
24153     +      from &multids;
24154     +   quit;
24155     +
24156     +   * check the synonym ds for multiword terms ;
24157     +   %if &synds_count ne 0 %then %do;
24158     +      %find_multiword_terms(data_in=&synds, data_append=_multiterms_);
24159     +   %end;
24160     +
24161     +   * check the stopTerms ds for multiword terms ;
24162     +   %if &stopds_count ne 0 %then %do;
24163     +      %find_multiword_terms(data_in=&stopds, data_append=_multiterms_);
24164     +   %end;
24165     +
24166     +   * check the startTerms ds for multiword terms;
24167     +   %if &startds_count ne 0 %then %do;
24168     +      %find_multiword_terms(data_in=&startds, data_append=_multiterms_);
24169     +   %end;
24170     +
24171     +   * check the multids for multiword terms ;
24172     +   %if &multids_count ne 0 %then %do;
24173     +      data work.multids_temp;
24174     +         length term $256 role $256;
24175     +         set &multids;
24176     +         if role eq '' then role='Noun';
24177     +      run;
24178     +      proc append base=_multiterms_ data=work.multids_temp(keep=term role) force;
24179     +      run;
24180     +      proc sql noprint;
24181     +         drop table work.multids_temp;
24182     +      run;
24183     +   %end;
24184     +
24185     +   * add lower and upper case variations to the multi word terms ;
24186     +
24187     +   data _multiterms_;
24188     +      set _multiterms_;
24189     +      term = transtrn(term, ':', '\:');
24190     +
24191     +      * output exactly as is ;
24192     +      output;
24193     +      * output lower case versions ;
24194     +      term=lowcase(term);
24195     +      output;
24196     +      * output upper case versions ;
24197     +      term=upcase(term);
24198     +      output;
24199     +      * output uppercase first letter of each term, lower rest ;
24200     +      term = propcase(term);
24201     +      output;
24202     +   run;
24203     +
24204     +   * remove duplicate term entries ;
24205     +   proc sort data= _multiterms_ nodupkey;
24206     +      by term role;
24207     +   run;
24208     +
24209     +   filename _multout "&multi";
24210     +
24211     +   * write out all the multiword terms ;
24212     +   data &multidsout;
24213     +      set _multiterms_;
24214     +      file _multout encoding="utf-8";
24215     +      put term ':3:' role;
24216     +   run;
24217     +
24218     +   %if ^%symexist(tm_debug) %then %let tm_debug=0;
24219     +   %if &tm_debug =0 %then %do;
24220     +      proc sql noprint;
24221     +         drop table work._multiterms_;
24222     +      quit;
24223     +   %end;
24224     +
24225     +%mend tmwritemulti;
24226     +
24227     +
24228     +/*
24229     +
24230     +%tmwritemulti(language="english", data=sashelp.engsynms);
24231     +
24232     +*/
24233     +
24234     +%macro find_multiword_terms(data_in=, data_append=);
24235     +
24236     +   data &data_in._temp (keep=term role);
24237     +      length term $ 256 role $ 256 category $ 256 child $ 256 childrole $ 256 parent $ 256 parentrole $ 256;
24238     +
24239     +      set &data_in;
24240     +
24241     +      if lengthn(kcompress(ktrim(term))) < lengthn(ktrim(term)) then do;
24242     +         if childrole ne '' then category = childrole;
24243     +         if role ne '' then category = role;
24244     +
24245     +         if lowcase(category) eq category then category=propcase(category) ;
24246     +
24247     +         if category in ('Adj','Adv','Noun','Prep','Conj','Interj','Pron','Prop', 'Verbadj') then role=category;
24248     +         else if category eq 'NOUN_GROUP' then role = 'Noun';
24249     +         else if category eq '' then role='Noun';
24250     +         else role = 'Prop';
24251     +
24252     +         output;
24253     +      end;
24254     +
24255     +      if "&data_in"="&synds" and anypunct(term,1) > 0 then do;
24256     +         term = prxchange('s/([\/\\<>,()])/ $1 /', -1, term);
24257     +         if role ne '' then category = role;
24258     +
24259     +         if category in ('Adj','Adv','Noun','Prep','Conj','Interj','Pron','Prop', 'Verbadj') then role=category;
24260     +         else if category eq 'NOUN_GROUP' then role = 'Noun';
24261     +         else if category eq '' then role='Noun';
24262     +         else role = 'Prop';
24263     +
24264     +         output;
24265     +      end;
24266     +
24267     +      if lengthn(kcompress(ktrim(parent))) < lengthn(ktrim(parent)) and ktrim(parent) ne ktrim(term) then do;
24268     +         term = parent;
24269     +         if parentrole ne '' then category = childrole;
24270     +
24271     +         if category in ('Adj','Adv','Noun','Prep','Conj','Interj','Pron','Prop', 'Verbadj') then role=category;
24272     +         else if category eq 'NOUN_GROUP' then role = 'Noun';
24273     +         else if category eq '' then role='Noun';
24274     +         else role = 'Prop';
24275     +         output;
24276     +      end;
24277     +   run;
24278     +
24279     +   proc append base=&data_append data=&data_in._temp force;
24280     +   run;
24281     +
24282     +   proc sql noprint;
24283     +      drop table &data_in._temp;
24284     +   quit;
24285     +%mend find_multiword_terms;
NOTE: %INCLUDE (level 1) ending.
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   data _null_;
MPRINT(TRAIN):   length parsevar urivar filteredvar $32;
MPRINT(TRAIN):   retain max_len 0;
MPRINT(TRAIN):   retain parsevar '';
MPRINT(TRAIN):   retain urivar '';
MPRINT(TRAIN):   retain filteredvar '';
MPRINT(TRAIN):   set EMWS3.TextParsing_VariableSet end=eof;
MPRINT(TRAIN):   if upcase(ROLE)='TEXT' and USE in ('Y', 'D') and length > max_len then do;
MPRINT(TRAIN):   parsevar = name;
MPRINT(TRAIN):   max_len = length;
MPRINT(TRAIN):   end;
MPRINT(TRAIN):   if upcase(ROLE)='TEXTLOC' and USE in ('D', 'Y') then filteredvar = name;
MPRINT(TRAIN):   if ROLE='URIVAR' and USE in ('D', 'Y') then urivar = name;
MPRINT(TRAIN):   if eof then do;
MPRINT(TRAIN):   call symput('tm_parsevar', parsevar);
MPRINT(TRAIN):   call symput('tm_urivar', urivar);
MPRINT(TRAIN):   call symput('tm_filteredvar', filteredvar);
MPRINT(TRAIN):   end;
MPRINT(TRAIN):   run;

NOTE: There were 1 observations read from the data set EMWS3.TEXTPARSING_VARIABLESET.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_PROPERTYCHANGE):   data WORK.EM_USER_PROPERTY;
MPRINT(EM_PROPERTYCHANGE):   length NAME $32 VALUE $400;
MPRINT(EM_PROPERTYCHANGE):   NAME = "parseVar";
MPRINT(EM_PROPERTYCHANGE):   VALUE = "review";
MPRINT(EM_PROPERTYCHANGE):   output;
MPRINT(EM_PROPERTYCHANGE):   run;

NOTE: The data set WORK.EM_USER_PROPERTY has 1 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_PROPERTYCHANGE):   run;
MPRINT(TRAIN):  ;
*------------------------------------------------------------*
NOTE: Variable used for parsing is: review
*------------------------------------------------------------*
MPRINT(TRAIN):   data _null_;
MPRINT(TRAIN):   dsid=open("EMWS3.TextParsing_synonymDS");
MPRINT(TRAIN):   check=varnum(dsid,'category');
MPRINT(TRAIN):   if check ne 0 then call symput('category_exists', '1');
MPRINT(TRAIN):   check=varnum(dsid,'termrole');
MPRINT(TRAIN):   if check ne 0 then call symput('termrole_exists', '1');
MPRINT(TRAIN):   check=varnum(dsid,'parentrole');
MPRINT(TRAIN):   if check ne 0 then call symput('parentrole_exists', '1');
MPRINT(TRAIN):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   proc sql noprint;
MPRINT(TRAIN):   create table work.internal_synds as select term, parent, termrole, parentrole from EMWS3.TextParsing_synonymDS;
NOTE: Table WORK.INTERNAL_SYNDS created, with 1 rows and 4 columns.

MPRINT(TRAIN):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   data work.internal_synds;
MPRINT(TRAIN):   set work.internal_synds;
MPRINT(TRAIN):   if KUPCASE(termrole) in ('PERSON', 'DATE', 'COMPANY', 'PERCENT', 'PROP_MISC', 'TITLE', 'TIME', 'PHONE', 'INTERNET', 'ORGANIZATION', 'CURRENCY', 'ADDRESS', 'NOUN_GROUP', 'MEASURE', 'LOCATION', 'SSN', 'TIME_PERIOD' ) then 
termrole=KUPCASE(termrole);
MPRINT(TRAIN):   if KUPCASE(parentrole) in ('PERSON', 'DATE', 'COMPANY', 'PERCENT', 'PROP_MISC', 'TITLE', 'TIME', 'PHONE', 'INTERNET', 'ORGANIZATION', 'CURRENCY', 'ADDRESS', 'NOUN_GROUP', 'MEASURE', 'LOCATION', 'SSN', 'TIME_PERIOD') then 
parentrole=KUPCASE(parentrole);
MPRINT(TRAIN):   run;

NOTE: There were 1 observations read from the data set WORK.INTERNAL_SYNDS.
NOTE: The data set WORK.INTERNAL_SYNDS has 1 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   proc sort data=work.internal_synds nodupkey;
MPRINT(TRAIN):   by term parent termrole parentrole ;
MPRINT(TRAIN):   run;

NOTE: There were 1 observations read from the data set WORK.INTERNAL_SYNDS.
NOTE: 0 observations with duplicate key values were deleted.
NOTE: The data set WORK.INTERNAL_SYNDS has 1 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   proc sql noprint;
MPRINT(TRAIN):   select count(*) into :stoplist_count from EMWS3.TextParsing_stopList;
MPRINT(TRAIN):   select count(*) into :startlist_count from EMWS3.TextParsing_startList;
MPRINT(TRAIN):   create view _trainview as select * from EMWS3.FIMPORT_train;
NOTE: SQL view WORK._TRAINVIEW has been defined.
MPRINT(TRAIN):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   data _null_;
MPRINT(TRAIN):   dsid=open("EMWS3.TextParsing_stopList");
MPRINT(TRAIN):   check=varnum(dsid,'role');
MPRINT(TRAIN):   if check ne 0 then call symput('role_exists', '1');
MPRINT(TRAIN):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   proc sort data=EMWS3.TextParsing_stopList nodupkey;
MPRINT(TRAIN):   by term role;
MPRINT(TRAIN):   run;

NOTE: Input data set is already sorted, no sorting done.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   data EMWS3.TextParsing_TRAIN(compress=yes);
MPRINT(TRAIN):   set _trainview;
MPRINT(TRAIN):   _document_ = _n_;
MPRINT(TRAIN):   label _document_= "Document";
MPRINT(TRAIN):   run;

NOTE: View EMWS3.FIMPORT_TRAIN.VIEW used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      
NOTE: There were 4400 observations read from the data set EMWS3.FIMPORT_DATA.
NOTE: There were 4400 observations read from the data set EMWS3.FIMPORT_TRAIN.
NOTE: There were 4400 observations read from the data set WORK._TRAINVIEW.
NOTE: The data set EMWS3.TEXTPARSING_TRAIN has 4400 observations and 7 variables.
NOTE: Compressing data set EMWS3.TEXTPARSING_TRAIN decreased size by 79.76 percent. 
      Compressed is 17 pages; un-compressed would require 84 pages.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   length KEY $32 DELETE $1 UNAME $32 ROLE $32 LEVEL $10 ORDER $8 COMMENT $64 LOWERLIMIT 8 UPPERLIMIT 8;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("_document_");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("ID");
MPRINT(EM_METACHANGE):   LEVEL = upcase("NOMINAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   run;

NOTE: The data set WORK.EM_METACHANGE has 1 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TMWRITEMULTI):   * create a multiword terms data set ;
MPRINT(TMWRITEMULTI):   proc sql noprint;
MPRINT(TMWRITEMULTI):   create table _multiterms_ (term char(256), role char(256));
NOTE: Table WORK._MULTITERMS_ created, with 0 rows and 2 columns.
MPRINT(TMWRITEMULTI):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TMWRITEMULTI):   proc sql noprint;
MPRINT(TMWRITEMULTI):   select count(*) into :synds_count from work.internal_synds;
MPRINT(TMWRITEMULTI):   select count(*) into :stopds_count from EMWS3.TextParsing_stopList;
MPRINT(TMWRITEMULTI):   select count(*) into :startds_count from EMWS3.TextParsing_startList;
MPRINT(TMWRITEMULTI):   select count(*) into :multids_count from EMWS3.TextParsing_multiDS;
MPRINT(TMWRITEMULTI):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TMWRITEMULTI):   * check the synonym ds for multiword terms ;
MPRINT(FIND_MULTIWORD_TERMS):   data work.internal_synds_temp (keep=term role);
MPRINT(FIND_MULTIWORD_TERMS):   length term $ 256 role $ 256 category $ 256 child $ 256 childrole $ 256 parent $ 256 parentrole $ 256;
MPRINT(FIND_MULTIWORD_TERMS):   set work.internal_synds;
MPRINT(FIND_MULTIWORD_TERMS):   if lengthn(kcompress(ktrim(term))) < lengthn(ktrim(term)) then do;
MPRINT(FIND_MULTIWORD_TERMS):   if childrole ne '' then category = childrole;
MPRINT(FIND_MULTIWORD_TERMS):   if role ne '' then category = role;
MPRINT(FIND_MULTIWORD_TERMS):   if lowcase(category) eq category then category=propcase(category) ;
MPRINT(FIND_MULTIWORD_TERMS):   if category in ('Adj','Adv','Noun','Prep','Conj','Interj','Pron','Prop', 'Verbadj') then role=category;
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq 'NOUN_GROUP' then role = 'Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq '' then role='Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else role = 'Prop';
MPRINT(FIND_MULTIWORD_TERMS):   output;
MPRINT(FIND_MULTIWORD_TERMS):   end;
MPRINT(FIND_MULTIWORD_TERMS):   if "work.internal_synds"="work.internal_synds" and anypunct(term,1) > 0 then do;
MPRINT(FIND_MULTIWORD_TERMS):   term = prxchange('s/([\/\\<>,()])/ $1 /', -1, term);
MPRINT(FIND_MULTIWORD_TERMS):   if role ne '' then category = role;
MPRINT(FIND_MULTIWORD_TERMS):   if category in ('Adj','Adv','Noun','Prep','Conj','Interj','Pron','Prop', 'Verbadj') then role=category;
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq 'NOUN_GROUP' then role = 'Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq '' then role='Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else role = 'Prop';
MPRINT(FIND_MULTIWORD_TERMS):   output;
MPRINT(FIND_MULTIWORD_TERMS):   end;
MPRINT(FIND_MULTIWORD_TERMS):   if lengthn(kcompress(ktrim(parent))) < lengthn(ktrim(parent)) and ktrim(parent) ne ktrim(term) then do;
MPRINT(FIND_MULTIWORD_TERMS):   term = parent;
MPRINT(FIND_MULTIWORD_TERMS):   if parentrole ne '' then category = childrole;
MPRINT(FIND_MULTIWORD_TERMS):   if category in ('Adj','Adv','Noun','Prep','Conj','Interj','Pron','Prop', 'Verbadj') then role=category;
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq 'NOUN_GROUP' then role = 'Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq '' then role='Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else role = 'Prop';
MPRINT(FIND_MULTIWORD_TERMS):   output;
MPRINT(FIND_MULTIWORD_TERMS):   end;
MPRINT(FIND_MULTIWORD_TERMS):   run;

NOTE: Variable child is uninitialized.
NOTE: Variable childrole is uninitialized.
NOTE: There were 1 observations read from the data set WORK.INTERNAL_SYNDS.
NOTE: The data set WORK.INTERNAL_SYNDS_TEMP has 1 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(FIND_MULTIWORD_TERMS):   proc append base=_multiterms_ data=work.internal_synds_temp force;
MPRINT(FIND_MULTIWORD_TERMS):   run;

NOTE: Appending WORK.INTERNAL_SYNDS_TEMP to WORK._MULTITERMS_.
NOTE: There were 1 observations read from the data set WORK.INTERNAL_SYNDS_TEMP.
NOTE: 1 observations added.
NOTE: The data set WORK._MULTITERMS_ has 1 observations and 2 variables.
NOTE: PROCEDURE APPEND used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(FIND_MULTIWORD_TERMS):   proc sql noprint;
MPRINT(FIND_MULTIWORD_TERMS):   drop table work.internal_synds_temp;
NOTE: Table WORK.INTERNAL_SYNDS_TEMP has been dropped.
MPRINT(FIND_MULTIWORD_TERMS):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TMWRITEMULTI):  ;
MPRINT(TMWRITEMULTI):   * check the stopTerms ds for multiword terms ;
MPRINT(FIND_MULTIWORD_TERMS):   data EMWS3.TextParsing_stopList_temp (keep=term role);
MPRINT(FIND_MULTIWORD_TERMS):   length term $ 256 role $ 256 category $ 256 child $ 256 childrole $ 256 parent $ 256 parentrole $ 256;
MPRINT(FIND_MULTIWORD_TERMS):   set EMWS3.TextParsing_stopList;
MPRINT(FIND_MULTIWORD_TERMS):   if lengthn(kcompress(ktrim(term))) < lengthn(ktrim(term)) then do;
MPRINT(FIND_MULTIWORD_TERMS):   if childrole ne '' then category = childrole;
MPRINT(FIND_MULTIWORD_TERMS):   if role ne '' then category = role;
MPRINT(FIND_MULTIWORD_TERMS):   if lowcase(category) eq category then category=propcase(category) ;
MPRINT(FIND_MULTIWORD_TERMS):   if category in ('Adj','Adv','Noun','Prep','Conj','Interj','Pron','Prop', 'Verbadj') then role=category;
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq 'NOUN_GROUP' then role = 'Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq '' then role='Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else role = 'Prop';
MPRINT(FIND_MULTIWORD_TERMS):   output;
MPRINT(FIND_MULTIWORD_TERMS):   end;
MPRINT(FIND_MULTIWORD_TERMS):   if "EMWS3.TextParsing_stopList"="work.internal_synds" and anypunct(term,1) > 0 then do;
MPRINT(FIND_MULTIWORD_TERMS):   term = prxchange('s/([\/\\<>,()])/ $1 /', -1, term);
MPRINT(FIND_MULTIWORD_TERMS):   if role ne '' then category = role;
MPRINT(FIND_MULTIWORD_TERMS):   if category in ('Adj','Adv','Noun','Prep','Conj','Interj','Pron','Prop', 'Verbadj') then role=category;
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq 'NOUN_GROUP' then role = 'Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq '' then role='Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else role = 'Prop';
MPRINT(FIND_MULTIWORD_TERMS):   output;
MPRINT(FIND_MULTIWORD_TERMS):   end;
MPRINT(FIND_MULTIWORD_TERMS):   if lengthn(kcompress(ktrim(parent))) < lengthn(ktrim(parent)) and ktrim(parent) ne ktrim(term) then do;
MPRINT(FIND_MULTIWORD_TERMS):   term = parent;
MPRINT(FIND_MULTIWORD_TERMS):   if parentrole ne '' then category = childrole;
MPRINT(FIND_MULTIWORD_TERMS):   if category in ('Adj','Adv','Noun','Prep','Conj','Interj','Pron','Prop', 'Verbadj') then role=category;
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq 'NOUN_GROUP' then role = 'Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq '' then role='Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else role = 'Prop';
MPRINT(FIND_MULTIWORD_TERMS):   output;
MPRINT(FIND_MULTIWORD_TERMS):   end;
MPRINT(FIND_MULTIWORD_TERMS):   run;

NOTE: Variable child is uninitialized.
NOTE: Variable childrole is uninitialized.
NOTE: Variable parent is uninitialized.
NOTE: Variable parentrole is uninitialized.
NOTE: There were 507 observations read from the data set EMWS3.TEXTPARSING_STOPLIST.
NOTE: The data set EMWS3.TEXTPARSING_STOPLIST_TEMP has 0 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(FIND_MULTIWORD_TERMS):   proc append base=_multiterms_ data=EMWS3.TextParsing_stopList_temp force;
MPRINT(FIND_MULTIWORD_TERMS):   run;

NOTE: Appending EMWS3.TEXTPARSING_STOPLIST_TEMP to WORK._MULTITERMS_.
NOTE: There were 0 observations read from the data set EMWS3.TEXTPARSING_STOPLIST_TEMP.
NOTE: 0 observations added.
NOTE: The data set WORK._MULTITERMS_ has 1 observations and 2 variables.
NOTE: PROCEDURE APPEND used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(FIND_MULTIWORD_TERMS):   proc sql noprint;
MPRINT(FIND_MULTIWORD_TERMS):   drop table EMWS3.TextParsing_stopList_temp;
NOTE: Table EMWS3.TEXTPARSING_STOPLIST_TEMP has been dropped.
MPRINT(FIND_MULTIWORD_TERMS):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TMWRITEMULTI):  ;
MPRINT(TMWRITEMULTI):   * check the startTerms ds for multiword terms;
MPRINT(TMWRITEMULTI):   * check the multids for multiword terms ;
MPRINT(TMWRITEMULTI):   data work.multids_temp;
MPRINT(TMWRITEMULTI):   length term $256 role $256;
MPRINT(TMWRITEMULTI):   set EMWS3.TextParsing_multiDS;
MPRINT(TMWRITEMULTI):   if role eq '' then role='Noun';
MPRINT(TMWRITEMULTI):   run;

NOTE: There were 384 observations read from the data set EMWS3.TEXTPARSING_MULTIDS.
NOTE: The data set WORK.MULTIDS_TEMP has 384 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TMWRITEMULTI):   proc append base=_multiterms_ data=work.multids_temp(keep=term role) force;
MPRINT(TMWRITEMULTI):   run;

NOTE: Appending WORK.MULTIDS_TEMP to WORK._MULTITERMS_.
NOTE: There were 384 observations read from the data set WORK.MULTIDS_TEMP.
NOTE: 384 observations added.
NOTE: The data set WORK._MULTITERMS_ has 385 observations and 2 variables.
NOTE: PROCEDURE APPEND used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TMWRITEMULTI):   proc sql noprint;
MPRINT(TMWRITEMULTI):   drop table work.multids_temp;
NOTE: Table WORK.MULTIDS_TEMP has been dropped.
NOTE: PROC SQL statements are executed immediately; The RUN statement has no effect.
MPRINT(TMWRITEMULTI):   run;
MPRINT(TMWRITEMULTI):   * add lower and upper case variations to the multi word terms ;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TMWRITEMULTI):   data _multiterms_;
MPRINT(TMWRITEMULTI):   set _multiterms_;
MPRINT(TMWRITEMULTI):   term = transtrn(term, ':', '\:');
MPRINT(TMWRITEMULTI):   * output exactly as is ;
MPRINT(TMWRITEMULTI):   output;
MPRINT(TMWRITEMULTI):   * output lower case versions ;
MPRINT(TMWRITEMULTI):   term=lowcase(term);
MPRINT(TMWRITEMULTI):   output;
MPRINT(TMWRITEMULTI):   * output upper case versions ;
MPRINT(TMWRITEMULTI):   term=upcase(term);
MPRINT(TMWRITEMULTI):   output;
MPRINT(TMWRITEMULTI):   * output uppercase first letter of each term, lower rest ;
MPRINT(TMWRITEMULTI):   term = propcase(term);
MPRINT(TMWRITEMULTI):   output;
MPRINT(TMWRITEMULTI):   run;

NOTE: There were 385 observations read from the data set WORK._MULTITERMS_.
NOTE: The data set WORK._MULTITERMS_ has 1540 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TMWRITEMULTI):   * remove duplicate term entries ;
MPRINT(TMWRITEMULTI):   proc sort data= _multiterms_ nodupkey;
MPRINT(TMWRITEMULTI):   by term role;
MPRINT(TMWRITEMULTI):   run;

NOTE: There were 1540 observations read from the data set WORK._MULTITERMS_.
NOTE: 385 observations with duplicate key values were deleted.
NOTE: The data set WORK._MULTITERMS_ has 1155 observations and 2 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TMWRITEMULTI):   filename _multout "D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextParsing\multiword.txt";
MPRINT(TMWRITEMULTI):   * write out all the multiword terms ;
MPRINT(TMWRITEMULTI):   data EMWS3.TextParsing_multiall;
MPRINT(TMWRITEMULTI):   set _multiterms_;
MPRINT(TMWRITEMULTI):   file _multout encoding="utf-8";
MPRINT(TMWRITEMULTI):   put term ':3:' role;
MPRINT(TMWRITEMULTI):   run;

NOTE: The file _MULTOUT is:
      Filename=D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextParsing\multiword.txt,
      RECFM=V,LRECL=131068,File Size (bytes)=0,
      Last Modified=16Jan2022:17:40:28,
      Create Time=01Jan2022:12:11:40

NOTE: 1155 records were written to the file _MULTOUT.
      The minimum record length was 10.
      The maximum record length was 29.
NOTE: There were 1155 observations read from the data set WORK._MULTITERMS_.
NOTE: The data set EMWS3.TEXTPARSING_MULTIALL has 1155 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TM_PARSE):   proc sql noprint;
MPRINT(TM_PARSE):   drop table EMWS3.TextParsing_tmconfig;
NOTE: Table EMWS3.TEXTPARSING_TMCONFIG has been dropped.
MPRINT(TM_PARSE):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_PARSE):   data _null_;
MPRINT(TM_PARSE):   posignore = "'AUX' 'CONJ' 'DET' 'INTERJ' 'PART' 'PREP' 'PRON'";
MPRINT(TM_PARSE):   posignore = transtrn(posignore, "'", '"');
MPRINT(TM_PARSE):   call symput("posignore", posignore);
MPRINT(TM_PARSE):   attribignore = "'NUM' 'PUNCT'";
MPRINT(TM_PARSE):   attribignore = transtrn(attribignore, "'", '"');
MPRINT(TM_PARSE):   call symput("attribignore", attribignore);
MPRINT(TM_PARSE):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_PARSE):   proc sql noprint;
MPRINT(TM_PARSE):   select count(*) into :stoplist_count from EMWS3.TextParsing_stopList;
MPRINT(TM_PARSE):   select count(*) into :startlist_count from EMWS3.TextParsing_startList;
MPRINT(TM_PARSE):   select count(*) into :synds_count from work.internal_synds;
MPRINT(TM_PARSE):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TM_PARSE):   proc hptmine data=EMWS3.TextParsing_TRAIN language=english;
MPRINT(TM_PARSE):   var review ;
MPRINT(TM_PARSE):   doc_id _document_;
MPRINT(TM_PARSE):   parse reducef=1 outterms=EMWS3.TextParsing_terms showdroppedterms nonoungroups stop=EMWS3.TextParsing_stopList syn=work.internal_synds entities=std multiterm="D:\Msc Data Science\CourseWorks\ASDM\Sentimental 
Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextParsing\multiword.txt" buildindex indexpath="D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextParsing\" outchild=EMWS3.TextParsing_tmout 
outpos=EMWS3.TextParsing_tmoutpos outconfig=EMWS3.TextParsing_tmconfig ;
MPRINT(TM_PARSE):   select "AUX" "CONJ" "DET" "INTERJ" "PART" "PREP" "PRON" / ignore ;
MPRINT(TM_PARSE):   select "NUM" "PUNCT" / group="attributes" ignore;
MPRINT(TM_PARSE):   ;
MPRINT(TM_PARSE):   performance details;
MPRINT(TM_PARSE):   run;

NOTE: No SPARSEFORMAT option is specified. SPARSEFORMAT=COO will be run by default.
NOTE: Stemming will be used in parsing.
NOTE: Tagging will be used in parsing.
NOTE: No TERMWGT option is specified. TERMWGT=ENTROPY will be run by default.
NOTE: No CELLWGT option is specified. CELLWGT=LOG will be run by default.
NOTE: The HPTMINE procedure is executing in single-machine mode.
WARNING:  1327 documents are either empty or cannot be read.
NOTE: There were 4400 observations read from the data set EMWS3.TEXTPARSING_TRAIN.
NOTE: There were 507 observations read from the data set EMWS3.TEXTPARSING_STOPLIST.
NOTE: There were 1 observations read from the data set WORK.INTERNAL_SYNDS.
NOTE: The data set EMWS3.TEXTPARSING_TERMS has 8413 observations and 11 variables.
NOTE: The data set EMWS3.TEXTPARSING_TMOUT has 58559 observations and 3 variables.
NOTE: The data set EMWS3.TEXTPARSING_TMOUTPOS has 62967 observations and 8 variables.
NOTE: The data set EMWS3.TEXTPARSING_TMCONFIG has 1 observations and 18 variables.
NOTE: The PROCEDURE HPTMINE printed page 2.
NOTE: PROCEDURE HPTMINE used (Total process time):
      real time           4.61 seconds
      cpu time            5.82 seconds
      

MPRINT(TM_PARSE):   proc sql noprint;
MPRINT(TM_PARSE):   create table EMWS3.TextParsing_terms as select *,_keep as keep from EMWS3.TextParsing_terms order by _keep desc,numdocs desc;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table EMWS3.TEXTPARSING_TERMS created, with 8413 rows and 12 columns.

MPRINT(TM_PARSE):   create table EMWS3.TextParsing_tmoutpos as select a.document as _document_, a.sentence as _sentence_, a._start_ as _offset_, a._end_ -a._start_+1 as _length_, b.key as _termnum_, c._count_ from EMWS3.TextParsing_tmoutpos as a, 
EMWS3.TextParsing_terms as b, EMWS3.TextParsing_tmout as c where b._ispar ne '+' and b.term=a.term and b.role=a.role and b.key=c._termnum_ and a.document=c._document_;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table EMWS3.TEXTPARSING_TMOUTPOS created, with 62967 rows and 6 columns.

MPRINT(TM_PARSE):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.05 seconds
      cpu time            0.04 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   proc sql;
MPRINT(TRAIN):   create table EMWS3.TextParsing_terms as select a.key label= "Key", a.term label= "Term", a.role, case a.role when 'Abbr' then "Abbr" when 'Adj' then "Adj" when 'Adv' then "Adv" when 'Aux' then "Aux" when 'Conj' then "Conj" when 'Det' then 
"Det" when 'Interj' then "Interj" when 'Noun' then "Noun" when 'Num' then "Num" when 'Part' then "Part" when 'Pref' then "Pref" when 'Prep' then "Prep" when 'Pron' then "Pron" when 'Prop' then "Prop" when 'Punct' then "Punct" when 'Verb' then "Verb" when 
'VerbAdj' then "VerbAdj" when 'PERSON' then "Person" when 'ORGANIZATION' then "Organization" when 'LOCATION' then "Location" when 'COMPANY' then "Company" when 'TITLE' then "Title" when 'PHONE' then "Phone Number" when 'DATE' then "Date" when 'TIME' then 
"Time" when 'INTERNET' then "Internet" when 'MEASURE' then "Measure" when 'NOUN_GROUP' then "Noun Group" when 'SSN' then "Social Security Number" when 'CURRENCY' then "Currency" when 'PERCENT' then "Percent" when 'TIME_PERIOD' then "Time Period" when 
'PROP_MISC' then "Miscellaneous Proper Noun" when 'VEHICLE' then "Vehicle" when 'ADDRESS' then "Address" else a.role end as rolestring label="Role", a.attribute, case a.attribute when 'Alpha' then "Alpha" when 'Mixed' then "Mixed" when 'Num' then "Num" 
when 'Entity' then "Entity" else a.ATTRIBUTE end as attrstring label="Attribute", a.freq label="Freq", a.numdocs label="# Docs", a.keep label="Keep", a._ispar label="Parent/Child Status", a.parent label="Parent", a.parent_id label="Parent ID" from 
EMWS3.TextParsing_terms a;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table EMWS3.TEXTPARSING_TERMS created, with 8413 rows and 12 columns.

MPRINT(TRAIN):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

MPRINT(TRAIN):   data EMWS3.TextParsing_tmconfig;
MPRINT(TRAIN):   length multiencoding $24 NG $3 ;
MPRINT(TRAIN):   set EMWS3.TextParsing_tmconfig;
MPRINT(TRAIN):   parseVar = lowcase("review                          ");
MPRINT(TRAIN):   displayVar = lowcase("");
MPRINT(TRAIN):   indexpath = "D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextParsing\";
MPRINT(TRAIN):   multiencoding="utf-8";
MPRINT(TRAIN):   filterLangs="";
MPRINT(TRAIN):   if NG="Y" then NG="STD";
MPRINT(TRAIN):   else if NG="N" then NG="OFF";
MPRINT(TRAIN):   if entities="STD" then entities="Y";
MPRINT(TRAIN):   language=lowcase(language);
MPRINT(TRAIN):   run;

NOTE: There were 1 observations read from the data set EMWS3.TEXTPARSING_TMCONFIG.
NOTE: The data set EMWS3.TEXTPARSING_TMCONFIG has 1 observations and 23 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   proc sort data=EMWS3.TextParsing_terms;
MPRINT(TRAIN):   by term role;
MPRINT(TRAIN):   run;

NOTE: There were 8413 observations read from the data set EMWS3.TEXTPARSING_TERMS.
NOTE: The data set EMWS3.TEXTPARSING_TERMS has 8413 observations and 12 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   data EMWS3.TextParsing_EMINFO;
MPRINT(TRAIN):   length TARGET KEY $32 DATA $43;
MPRINT(TRAIN):   key="LastTMNode";
MPRINT(TRAIN):   data="TextParsing";
MPRINT(TRAIN):   output;
MPRINT(TRAIN):   key="LastTMNodeType";
MPRINT(TRAIN):   data="TextParsing";
MPRINT(TRAIN):   output;
MPRINT(TRAIN):   key="LastTextParsing";
MPRINT(TRAIN):   data="TextParsing";
MPRINT(TRAIN):   output;
MPRINT(TRAIN):   run;

NOTE: Variable TARGET is uninitialized.
NOTE: The data set EMWS3.TEXTPARSING_EMINFO has 3 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   filename temp;
NOTE: Fileref TEMP has been deassigned.
MPRINT(MAIN):  ;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End TRAIN: TextParsing;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
24286      *------------------------------------------------------------*;
24287      * End TRAIN: TextParsing;
24288      *------------------------------------------------------------*;
24289      
24290      
24291      
24292      

24293      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
24294      * Close any missing semi colons;
MPRINT(EM_DIAGRAM):   * Close any missing semi colons;
24295      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
24296      ;
MPRINT(EM_DIAGRAM):   ;
24297      ;
MPRINT(EM_DIAGRAM):   ;
24298      ;
MPRINT(EM_DIAGRAM):   ;
24299      ;
MPRINT(EM_DIAGRAM):   ;
24300      quit;
MPRINT(EM_DIAGRAM):   quit;
24301      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
24302      * Close any unbalanced quotes;
MPRINT(EM_DIAGRAM):   * Close any unbalanced quotes;
24303      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
24304      /*; *"; *'; */
24305      ;
MPRINT(EM_DIAGRAM):   ;
24306      run;
MPRINT(EM_DIAGRAM):   run;
24307      quit;
MPRINT(EM_DIAGRAM):   quit;
24308      /* Reset EM Options */
24309      options formchar="|----|+|---+=|-/\<>*";
MPRINT(EM_DIAGRAM):   options formchar="|----|+|---+=|-/\<>*";
24310      options nocenter ls=256 ps=10000;
MPRINT(EM_DIAGRAM):   options nocenter ls=256 ps=10000;
24311      goptions reset=all device=GIF NODISPLAY;
MPRINT(EM_DIAGRAM):   goptions reset=all device=GIF NODISPLAY;
24312      proc sort data=WORK.EM_METACHANGE;
MPRINT(EM_DIAGRAM):    proc sort data=WORK.EM_METACHANGE;
24313      by key uname;
MPRINT(EM_DIAGRAM):   by key uname;
24314      run;
MPRINT(EM_DIAGRAM):   run;

NOTE: There were 1 observations read from the data set WORK.EM_METACHANGE.
NOTE: The data set WORK.EM_METACHANGE has 1 observations and 9 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

24315      filename x "D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextParsing\CDELTA_TRAIN.sas";
MPRINT(EM_DIAGRAM):    filename x "D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextParsing\CDELTA_TRAIN.sas";
24316      data _null_;
MPRINT(EM_DIAGRAM):   data _null_;
24317      file x;
MPRINT(EM_DIAGRAM):   file x;
24318      put 'if upcase(NAME) = "_DOCUMENT_" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "_DOCUMENT_" then do;';
24319      put 'ROLE = "ID";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "ID";';
24320      put 'LEVEL = "NOMINAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "NOMINAL";';
24321      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
24322      run;
MPRINT(EM_DIAGRAM):   run;

NOTE: The file X is:
      Filename=D:\Msc Data Science\CourseWorks\ASDM\Sentimental Analysis\Sentimental_Analysis_SAS\Workspaces\EMWS3\TextParsing\CDELTA_TRAIN.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=0,
      Last Modified=16Jan2022:17:40:33,
      Create Time=01Jan2022:12:10:19

NOTE: 4 records were written to the file X.
      The minimum record length was 4.
      The maximum record length was 39.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

24323      filename x;
MPRINT(EM_DIAGRAM):   filename x;
NOTE: Fileref X has been deassigned.
MPRINT(EM_DIAGRAM):    proc printto;
MPRINT(EM_DIAGRAM):   run;
